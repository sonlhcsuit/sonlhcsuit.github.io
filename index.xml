<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Sơn Lưu Blog</title><link>https://sonlhcsuit.github.io/</link><description>Recent content on Sơn Lưu Blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sun, 23 May 2021 20:34:57 +0700</lastBuildDate><atom:link href="https://sonlhcsuit.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>Object Oriented Programing Implementations</title><link>https://sonlhcsuit.github.io/p/oop-implementation/</link><pubDate>Sun, 23 May 2021 20:34:57 +0700</pubDate><guid>https://sonlhcsuit.github.io/p/oop-implementation/</guid><description>&lt;img src="https://sonlhcsuit.github.io/p/oop-implementation/cover.jpg" alt="Featured image of post Object Oriented Programing Implementations" />&lt;h1 id="disadvantages-of-previous-paradigms">Disadvantages of previous paradigms&lt;/h1>
&lt;p>Các phương pháp lập trình trước kia (procedural programming &amp;amp; structured programming) đòi hỏi một sự quản lý cực kỳ chặt chẽ khi code. Tuy nhiên với bản chất của procedural programming là viết nhiều dòng lệnh chạy từ trên xuống thì thực sự có quản lý có tốt tới đâu thì chúng ta vẫn gặp trường hợp bad code khi chương trình trở trên to hơn (nhiều tính năng hơn). Một bước tiến quan trọng đó chính là định nghĩa &lt;code>function&lt;/code>/&lt;code>procedure&lt;/code>/&lt;code>module&lt;/code> (nhiều functions liên quan tới nhau được đặt trong cùng 1 file) được tạo ra giúp cho việc code nên dễ dàng hơn (tái sử dụng code). Tuy nhiên từ một ví dụ thực tế (1 trận đấu pokemon chẳng hạn), nhiều hàm đều có quyền truy cập tới các giá trị global để thay đổi dữ liệu( ví dụ máu, mp, pp, &amp;hellip;). Từ một góc độ nào đó, việc này vẫn còn tồn đọng nhiều rủi ro chưa xuất hiện. Bằng việc thay đổi khái niệm của một chương trình &lt;code>Algorithms + Data Structure = Programs&lt;/code> thành những một công thức tổng quảt quát hơn đã giúp sinh ra lập trình hướng đối tượng.&lt;/p>
&lt;h1 id="object-oriented-programming">Object Oriented Programming&lt;/h1>
&lt;p>Dựa vào công thức: &lt;code>Algorithms + Data Structure = Programs&lt;/code>, ta có hiểu đơn giản: &lt;code>Data Structure&lt;/code> ở đây là dữ liệu (chính xác hơn thì là cấu trúc dữ liệu) và &lt;code>Algorithms&lt;/code> là hàm (chính xác hơn là giải thuật). Các thành phần trên góp phần tạo nên chương trình, tuy nhiên lại khó để quản lý khi mà chương trình càng ngày càng lớn, càng khó để mô hình hoá, để quản lý hơn. Từ góc độ này, chúng ta có &lt;code>Data&lt;/code> ở một nơi và &lt;code>Function&lt;/code> ở một nơi, thì nảy sinh ra ý tưởng: &amp;ldquo;Tại sao không gom data &amp;amp; function lại thành 1 nhỉ?&amp;rdquo; Ý tưởng cơ bản của OOP nằm ở việc gom nhiều &lt;code>data&lt;/code> và &lt;code>function&lt;/code> liên quan tới nhau (nghĩa là thực hiện việc thay đổi trên &lt;code>data&lt;/code>) chung với nhau thành một đơn vị gọi là &lt;code>object&lt;/code>. Và việc mô hình hoá cũng dễ dàng hơn khi chúng ta liên tưởng các &lt;code>object&lt;/code> tới những thứ cụ thể ở cuộc sống thực tế.&lt;/p>
&lt;p>&lt;code>Object&lt;/code> gồm những thành phần sau:&lt;/p>
&lt;ul>
&lt;li>&lt;code>Attribute&lt;/code>: nhằm thể hiện thông tin, dữ liệu của &lt;code>object&lt;/code>&lt;/li>
&lt;li>&lt;code>Behavior&lt;/code>: nhằm thể hiện các hành động mà &lt;code>object&lt;/code> có thể thực hiện&lt;/li>
&lt;/ul>
&lt;p>Để dễ hình dung thì hãy tưởng tượng một con &lt;code>mèo anh lông ngắn&lt;/code> là một thì &lt;code>attribute&lt;/code> (còn được gọi là &lt;code>characteristics&lt;/code>) sẽ là những thông tin liên quan tới bản chất của &lt;code>object&lt;/code> (lông màu xám, lông ngắn, mắt xanh, đuôi cụt, 3 tuổi, nặng 10kg, &amp;hellip;). Về phần &lt;code>behavior&lt;/code> là những hành động liên quan tới đối tượng (ăn: giúp cơ thể phát triển, cân nặng tăng,&amp;hellip;)&lt;/p>
&lt;h1 id="class--object">Class &amp;amp; Object&lt;/h1>
&lt;p>&lt;code>Object&lt;/code> &amp;amp; &lt;code>Class&lt;/code> là 2 khái niệm cơ bản, nền tảng, quan trọng nhất của OOP.&lt;/p>
&lt;p>&lt;code>Object&lt;/code> gồm &lt;code>attribute&lt;/code> &amp;amp; &lt;code>behavior&lt;/code> (&lt;code>inner function&lt;/code>,&lt;code>method&lt;/code>,&lt;code>member function&lt;/code>, &amp;hellip;). Các &lt;code>object&lt;/code> sẽ tương tác với nhau thông qua các &lt;code>method&lt;/code> (&lt;code>inner function&lt;/code>), và cập nhật lại dữ liệu của &lt;code>object&lt;/code> gián tiếp, không phải trực tiếp bằng cách gán giá trị mới cho các &lt;code>attribute&lt;/code> mà thông qua con đường là sự dụng các hàm chức năng (&lt;code>method&lt;/code>). Đây là đặc điểm cơ sở của tính chất đầu tiên của OOP : &lt;code>Data encapsulation &amp;amp; information hidding&lt;/code>&lt;/p>
&lt;p>&lt;code>Class&lt;/code> là một khái niệm trừu tượng hơn, bao quát hơn &lt;code>object&lt;/code>, là khuôn mẫu để định hình các &lt;code>object&lt;/code> (các &lt;code>object&lt;/code> có &lt;code>attribute&lt;/code> nào và &lt;code>behavior&lt;/code> nào) từ dưới góc độ thực tế. Hãy xem xét thử một vài game RPG có các &lt;code>class&lt;/code> character như là &lt;code>knight&lt;/code>, &lt;code>warrior&lt;/code>, &lt;code>magician&lt;/code>,&amp;hellip; Tuỳ thuộc vào các &lt;code>class&lt;/code> này, ta có thể biết được khả năng của nhân vật &lt;code>knight&lt;/code> thì có máu nhiều và phòng thủ cao, &lt;code>magician&lt;/code> thì có sát thương lớn và phòng thủ kém,&amp;hellip; Từ góc độ lập trình, thì &lt;code>object&lt;/code> được xem là thành phần của &lt;code>class&lt;/code>. Lấy một ví dụ thực tế, ta có 1234 là số nguyên, thuộc về tập hợp số nguyên, và bởi vì nhiều ngôn ngữ đã được cài đặt sẵn số nguyên là gì, nên chúng ta có thể sử dụng ngay lập tức mà không cần phải khai báo thêm, tất nhiên là đi kèm các behavior khác như cộng trừ nhân chia các số khác. &lt;code>Class&lt;/code> có xu hướng tổng quát, còn &lt;code>object&lt;/code> thì có xu hướng cụ thể. Đơn giản hơn thì &lt;code>Class&lt;/code> chính là khuôn mẫu của &lt;code>object&lt;/code>, chúng ta từ một &lt;code>class&lt;/code>, có thể tạo ra nhiều &lt;code>object&lt;/code> thuộc &lt;code>class&lt;/code> đó. Và những &lt;code>object&lt;/code> thuộc cùng &lt;code>class&lt;/code> với nhau, sẽ có các &lt;code>behavior&lt;/code>, &lt;code>attribute&lt;/code> như nhau (tất nhiên là khác giá trị) đã được định nghĩa chung ở &lt;code>class&lt;/code>, &lt;code>object&lt;/code> là &lt;code>instance&lt;/code> của &lt;code>class&lt;/code> (thể hiện của &lt;code>class&lt;/code>).&lt;/p>
&lt;p>Khi viết một chương trình theo dạng OOP, chúng ta dành đa phần thời gian vào việc khai báo &lt;code>class&lt;/code> , sau đó tạo các &lt;code>object&lt;/code> và để chúng tương tác với nhau (cộng phân số, nông trại vui vẻ,&amp;hellip;)&lt;/p>
&lt;h1 id="4-fundamental-principles-of-oop">4 fundamental principles of OOP&lt;/h1>
&lt;p>Lập trình hướng đối tượng là tư tưởng, là phong cách lập trình, chứ không phải là một kỹ thuật. Bản chất của hướng đối tượng có thể dựa trên các nguyên lý cơ bản sau:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>Data encapsulation&lt;/strong> : Các đối tượng chỉ có thể tương tác với nhau thông qua các &lt;code>method&lt;/code> phù hợp, không được trực tiếp thay đổi &lt;code>attribute&lt;/code> của nhau. &lt;code>Attribute&lt;/code> là dữ liệu sẽ được bảo vệ, che giấu ở trong đối tượng đó.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Inheritance&lt;/strong>: Các &lt;code>class&lt;/code> có thể có nhiều &lt;code>attribute&lt;/code> giống nhau, khi khai báo &lt;code>class&lt;/code> thì ta không cần phải khai báo lại mà có thể tận dụng các &lt;code>attribute&lt;/code> &amp;amp; &lt;code>method&lt;/code> có sẵn để tận dụng thời gian và không gian thông qua việc kế thừa. Các &lt;code>derived class&lt;/code> (class con) sẽ kế thừa sản nghiệp (attribute &amp;amp; method) của &lt;code>base class&lt;/code> (class cha). Mục đích chính của kế thừa là để nhiều &lt;code>object&lt;/code> có chung nhiều đặc điểm để dễ bề quản lý.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Polymerization&lt;/strong>: Nhiều &lt;code>derived class&lt;/code> có một cách thực hiện các &lt;code>behavior&lt;/code> được kế thừa từ &lt;code>base class&lt;/code> khác nhau. Ví dụ như hành động ăn thì con bò sẽ khác sư tử (vẫn là nạp năng lượng vào cơ thể - thay đổi các &lt;code>attribute&lt;/code>), di chuyển thì con cá sẽ bơi bằng mang và ngựa thì chạy bằng chân. Tuỳ thuộc vào từng class cụ thể mà sẽ có nhiều cách thể hiện cùng một &lt;code>behavior&lt;/code> đã được kế thừa từ &lt;code>base class&lt;/code>.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Abstraction&lt;/strong> : &lt;code>Abstraction&lt;/code> thông thường đi kèm với &lt;code>Polymerization&lt;/code> để tạo nên một cặp bài trùng hoàn hảo. &lt;code>Abstraction&lt;/code> mang tính khái quát hoát, cố gắng tìm điểm chung nhất để có thể tạo nên &lt;code>class&lt;/code> chung nhất, rồi sau đó kết hợp với &lt;code>polymerization&lt;/code> để tạo ra sự đa dạng trong cách thực hiện nhưng lại dẫn tới cùng kết quả. Nói ví dụ về điện thoại, ta có rất nhiều điện thoại ở trên đời, nhưng ta có cần phải quan tâm hết cơ chế chúng không (Ví dụ làm sao để gọi điện, nhắn tin, tính toán,..). Nếu với một người làm việc với kỹ năng cứng là chế tạo điện thoại thì cần, nhưng với end-user thì có cần thiết không? End-user không cần biết điện thoại được chế tạo như nào (gồm CPU gì, RAM bao nhiêu, Cache thế nào, làm sao màn hình cảm ứng lại xài được, &amp;hellip;) mà chỉ quan tâm tới việc xài như thế nào. Việc gửi tin nhắn hoặc gọi điện 1 Nokia cũng có thể gửi được tin nhắn cho 1 cái iPhone XXX Pro Max. &lt;code>Abstraction&lt;/code> ở đây chính ta việc trừu tượng hoá các behavior chung nhất (gửi tin nhắn, gọi điện,&amp;hellip;) và kết hợp với &lt;code>polymerization&lt;/code> để tạo nên sự đa dạng nhưng vẫn dễ dàng quản lý.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Ở trên chỉ là đôi chút kinh nghiệm nhỏ, tâm đắc được rút ra từ bản thân tác giả.&lt;/strong>&lt;/p>
&lt;h1 id="implement-language-with-oo-supported">Implement language with OO supported&lt;/h1>
&lt;p>Có 2 cách (hoặc tác giả chưa biết thêm cách thứ 3 vì kiến thức hạn hẹp) để &lt;code>implement&lt;/code> một ngôn ngữ hỗ trợ hướng đối tượng (OO supported). Đó là &lt;code>class-base&lt;/code> &amp;amp; &lt;code>prototype-base&lt;/code>.
&lt;code>Class-base&lt;/code> là cách &lt;code>implement&lt;/code> (cài đặt) ngôn ngữ lập trình hướng đối tượng chặt chẽ, thể hiện được khía cạnh mạnh mẽ của &lt;strong>O&lt;/strong>bject &lt;strong>O&lt;/strong>riented (hướng đối tượng), các ngôn ngữ bậc trung như &lt;code>C++&lt;/code>, &lt;code>Java&lt;/code>, &lt;code>C#&lt;/code>,&amp;hellip; được cài đặt theo cách này. Tuy nhiên điểm yếu là khi bắt đầu code với các ngôn ngữ này thì nền tảng về lập trình, cũng như hiểu biết về hướng đối tượng, kỹ thuật lập trình là thứ không thể thiếu. Cài đặt dài dòng rườm ra mất thời gian của coder nhưng thứ tốt hơn được nhận lấy là code dễ quản lý, tìm lỗi, bảo trì. Nôm na là sẽ đánh đổi công sức của coder lấy về một source code tốt (hoặc ít nhất thì đó là mục tiêu lý tưởng).&lt;/p>
&lt;p>Cách ngược lại là &lt;code>protoype-base&lt;/code> thì giúp coder viết code nhanh và mượt hơn, không strict nhiều tính chất chặt chẽ, dễ tiếp cận với người mới. Mặt khác thì nhận sự hạn chế trong việc tuỳ biến các đối tượng. Đồng thời phải sinh ra thêm khái niệm mới để đảm bảo tính chất của &lt;strong>OO&lt;/strong> về mặt tư tưởng. &lt;strong>Javascript&lt;/strong> &amp;amp; &lt;strong>Python&lt;/strong> là 2 ngôn ngữ điển hình cài đặt OOP theo prototype&lt;/p>
&lt;h1 id="prototype-overview">Prototype overview&lt;/h1>
&lt;ul>
&lt;li>
&lt;p>&lt;code>Prototype-bases&lt;/code> implementation là việc cài đặt OOP, đặc biệt là &lt;code>Inheritance&lt;/code> các &lt;code>behavior&lt;/code> (kế thừa các hành động) thông qua một &lt;code>predefined object&lt;/code> (&lt;code>object&lt;/code> đã được khởi tạo sẵn) gọi là &lt;strong>prototype&lt;/strong> . Việc tạo ra 1 &lt;code>object&lt;/code> trong các ngôn ngữ này được gọi là &amp;ldquo;clone&amp;rdquo; (chứ không phải &lt;code>construct&lt;/code> - class-base implementation) dựa trên một &lt;code>object&lt;/code> chuẩn nhất (&lt;code>generalized object&lt;/code> - việc tạo ra &lt;code>object&lt;/code> mới được gọi là clone hoặc extend)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Nguyên lý này giúp coder tập trung vào việc xử lý các &lt;code>behavior cụ thể&lt;/code> của &lt;code>một object cụ thể&lt;/code> tại &lt;code>một thời điểm&lt;/code> cụ thể hơn là việc phải &lt;strong>định nghĩa chúng nó&lt;/strong> trước (class-base implementation luôn ưu tiên abstraction, điển hình là Java/Microsoft Java, tới mức cao nhất) bằng việc định nghĩa class. Sau khi có những &lt;code>object&lt;/code> cụ thể rồi thì lúc đó coder mới phải quan tâm tới việc tạo ra &lt;code>archetypal structure&lt;/code> (cấu trúc nguyên mẫu).&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Và khi coder thực hiện implementation các &lt;code>program&lt;/code> theo style &lt;code>prototype-base&lt;/code> thì các ngôn ngữ hỗ trợ thường có xu hướng thay đổi, tạo ra, thực thi, kiểm tra các &lt;code>behavior&lt;/code> tại &lt;code>run-time&lt;/code>hơn là ở c&lt;code>ompile-time&lt;/code>. Điều này dẫn tới một nguy cơ tiềm ẩn: các behavior có khả năng gây ra &lt;code>exception&lt;/code> cao(không phải là class-base không có khả năng gây ra &lt;code>run-time exception&lt;/code>). Điển hình là các &lt;code>callback function&lt;/code> ở &lt;strong>Javascript&lt;/strong>. Các &lt;code>interpreter&lt;/code> &amp;amp; &lt;code>dynamic typed&lt;/code> language (Javascript, Python, &amp;hellip;) thường là một lựa chọn hoàn hảo dành cho &lt;code>prototype-base OOP implementation&lt;/code>.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="construction">Construction&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>Khi nói tới OOP, tạo ra một object thì chắc hẳn phải nói tới &lt;code>constructor&lt;/code>, và trước khi có thể sử dụng được &lt;code>constructor&lt;/code> thì phải định nghĩa &lt;code>class&lt;/code>, các &lt;code>attribute&lt;/code> trước, đối ngược hoàn toàn với việc tạo &lt;code>object&lt;/code> trước rồi mới định nghĩa các &lt;code>attribute&lt;/code> &amp;amp; &lt;code>behavior&lt;/code> &lt;code>như prototype-base&lt;/code>.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Từ một vài phiên bản mới thì &lt;strong>Javascript&lt;/strong> đã khắc phục chuyện này bằng cách thêm từ khoá &lt;code>new&lt;/code> cùng với &lt;code>constructor&lt;/code> để khiến bản thân có thể trông giống như &lt;code>class-base &lt;/code>implementation từ đó dễ tiếp cận đối với các coder từ &lt;code>class-base&lt;/code> chuyển sang (Java/Microsoft Java/ C++)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Một ưu điểm của &lt;strong>Javascript&lt;/strong> là có thể khởi tạo object &lt;code>literal&lt;/code> (theo nghĩa đen). Một điều thú vị ở đây là &lt;code>Inheritance&lt;/code> được thực hiện thông qua việc &lt;code>clone&lt;/code>, nghĩa là chúng ta sẽ tạo một &lt;code>doppelganger&lt;/code> của object cụ thể, tất cả &lt;code>attribute&lt;/code> &amp;amp; &lt;code>behavior&lt;/code> của object mới vừa đươc &lt;code>clone&lt;/code> đều giống chính xác như bản gốc và di chuyển vào nơi nó thuộc về, và coder sẽ thực hiện việc &lt;code>manipulate&lt;/code> / &lt;code>modify&lt;/code> phiên bản &lt;code>doppelganger&lt;/code> này thành &lt;code>object&lt;/code> mong muốn.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="delegation">Delegation&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>Nếu trong &lt;code>class-base&lt;/code> OOP, việc xác định một &lt;code>behavior&lt;/code> của object sẽ dựa vào &lt;code>Inheritance tree&lt;/code>, thì đại diện của &lt;code>prototype-base&lt;/code> là &lt;strong>Javascript&lt;/strong> sẽ sử dụng một cơ chế gọi là &lt;code>delegation&lt;/code> nhằm xác định đúng &lt;code>prototype&lt;/code> (&lt;code>attribute&lt;/code> &amp;amp; &lt;code>behavior&lt;/code> của &lt;code>object&lt;/code>) tại thời điểm runtime &amp;hellip;&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Javascript&lt;/strong> implement &lt;code>prototype&lt;/code> thông qua &lt;code>Object.prototype&lt;/code>, và tất cả những object khác kế thừ từ object này cũng mang theo một màu như vậy, tuy nhiên lại không thể hiện rõ ra ở &lt;code>obj.prototype&lt;/code> mà được ngầm hiểu nhờ cơ chế &lt;code>delegation&lt;/code> và được ẩn giấu ở &lt;code>[[Prototype]]&lt;/code> cũng tức là những thứ &lt;code>đã được clone từ original version&lt;/code>. Để truy cập thì ta chỉ cần dấu &lt;code>dot(.)&lt;/code> mà thôi . Javascript sẽ truy cập vào &lt;code>[[Prototype]]&lt;/code> hiện tại của object để có thể lấy ra được thứ mình muốn.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Attribute &amp;amp; behavior của original khi được clone sẽ được hop-in (chuyển vào) &lt;code>[[Prototype]]&lt;/code> tạo thành 1 cái cây. Nếu chẳng may phiên bản &lt;code>doppelganger&lt;/code> có tồn tại một &lt;code>behavior&lt;/code> trùng tên &lt;code>original version&lt;/code> với cái cũ thì cũng không sao bởi vì cơ chế &lt;code>delegation&lt;/code> duyệt &lt;code>prototype&lt;/code> bottom-up. Nhìn hình thì các bạn có thể hiểu rõ hơn một xíu.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>&lt;figure style="flex-grow: 269; flex-basis: 645px">
&lt;a href="https://sonlhcsuit.github.io/p/oop-implementation/image-1.png" data-size="958x356">&lt;img src="https://sonlhcsuit.github.io/p/oop-implementation/image-1.png"
srcset="https://sonlhcsuit.github.io/p/oop-implementation/image-1_hu16fdedee5ecd38efce0f7645e37599b8_58863_480x0_resize_box_3.png 480w, https://sonlhcsuit.github.io/p/oop-implementation/image-1_hu16fdedee5ecd38efce0f7645e37599b8_58863_1024x0_resize_box_3.png 1024w"
width="958"
height="356"
loading="lazy"
alt="Archetypal Structure">
&lt;/a>
&lt;figcaption>Archetypal Structure&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;h2 id="concatenation">Concatenation&lt;/h2>
&lt;ul>
&lt;li>Hiểu một cách đơn giản về việc &lt;code>concatenation&lt;/code> là khi bạn thay đổi &lt;code>behavior&lt;/code> của object lớn thì những &lt;code>doppelganger verions&lt;/code> của &lt;code>object&lt;/code> đó không hề bị ảnh hưởng. Nó có thể là một điểm mạnh, hoặc cũng có thể là một điểm yếu khi có những &lt;code>behavior&lt;/code> không đồng bộ nhưng vậy. Tác giả vì còn kém nên chỉ thấy được bất lợi trước mắt là phải gán lại tất cả &lt;code>behavior&lt;/code> cho các object đã được khai báo (nếu gặp trường hợp cần thay đổi &lt;code>behavior&lt;/code> như thế này)&lt;/li>
&lt;/ul>
&lt;p>Sẽ ráng update một bài nói chi tiết về việc Javascript/Python implement theo Prototype này có điểm lợi và hại gì.&lt;/p>
&lt;hr>
&lt;h1 id="references--more-resources">References &amp;amp; more resources&lt;/h1>
&lt;ul>
&lt;li>Object-Oriented Programming in C++, Fourth Edition p.10 - p.25&lt;/li>
&lt;li>&lt;a class="link" href="https://en.wikipedia.org/wiki/Prototype-based_programming" target="_blank" rel="noopener"
>https://en.wikipedia.org/wiki/Prototype-based_programming&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create" target="_blank" rel="noopener"
>https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create&lt;/a>&lt;/li>
&lt;/ul>
&lt;h3 id="ps">P/S:&lt;/h3>
&lt;p>Nếu có gì sai sót xin gửi email cho mình để cập nhật, xin cảm ơn!&lt;/p></description></item><item><title>Power and logarithms</title><link>https://sonlhcsuit.github.io/p/power/</link><pubDate>Sun, 23 May 2021 19:18:38 +0700</pubDate><guid>https://sonlhcsuit.github.io/p/power/</guid><description>&lt;img src="https://sonlhcsuit.github.io/p/power/cover.png" alt="Featured image of post Power and logarithms" />&lt;p>Một trong nhiều vấn đề khá là nan giải (thực ra không phải là nan giải, &amp;ldquo;người ta&amp;rdquo; đã giải quyết nó từ lâu rồi - từ này ở đây với ý nghĩa cách tiếp cận khó khăn) trong lập trình, hoặc toán học đó là phép toán luỹ thừa. Một câu hỏi có thể hay được đặt ra đó là: &amp;ldquo;Làm sao để tính luỹ thừa bậc n của một số bất kỳ?&amp;rdquo;. Vấn đề trở nên rất đơn giản nếu như chúng ta sử dụng các ngôn ngữ lập trình Javascript, Python, hoặc là các thư viện kèm theo của các ngôn ngữ bậc thấp như &lt;em>math.h&lt;/em> của C / &lt;em>cmath&lt;/em> của C++. Nhưng trong trường hợp không không thể sử dụng các built-in, chúng ta tính luỹ thừa như thế nào? Để hiểu rõ được việc làm sao chúng ta có thể cài đặt được phép luỹ thừa, ta sẽ cần rất nhiều kiến thức về toán học cơ bản (bên cạnh đó còn)&lt;/p>
&lt;h1 id="exponent-as-natural-number">Exponent as natural number&lt;/h1>
&lt;p>Bằng một vài định nghĩa toán học cơ bản, ta biết được rằng phép toán luỹ thừa là việc thực hiện các phép nhân liên tục. Cụ thể hơn, &lt;em>base&lt;/em> được nhân với chính bản thân &lt;em>n&lt;/em> lần. Phép toán luỹ thừa đồng thời là một ví dụ điển hình về sự tăng trưởng.&lt;/p>
&lt;p>$$
\underbrace{b^n = b.b.b&amp;hellip;b}_\text{n times}
$$&lt;/p>
&lt;p>Bằng định nghĩa này, ta có thể tự implement hàm luỹ thừa như sau:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">pow&lt;/span>(&lt;span style="color:#a6e22e">base&lt;/span>,&lt;span style="color:#a6e22e">deg&lt;/span>){
&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">p&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">i&lt;/span>&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>;&lt;span style="color:#a6e22e">i&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#a6e22e">deg&lt;/span>;&lt;span style="color:#a6e22e">i&lt;/span>&lt;span style="color:#f92672">++&lt;/span>){
&lt;span style="color:#a6e22e">p&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">p&lt;/span>&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">base&lt;/span>
}
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">p&lt;/span>;
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Tuy nhiên hàm luỹ thừa vẫn chưa đủ nếu chỉ có bấy nhiêu, ta cần phải xem xét, bao quát cả các trường hợp đặc biệt như là &lt;code>NaN, 0, 1, infinity&lt;/code>. Bằng việc thêm các trường hợp đặc biệt, hàm &lt;code>pow&lt;/code> đã tốt hơn một tí.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">pow&lt;/span>(&lt;span style="color:#a6e22e">base&lt;/span>,&lt;span style="color:#a6e22e">deg&lt;/span>){
&lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#a6e22e">base&lt;/span> &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#f92672">||&lt;/span> &lt;span style="color:#a6e22e">base&lt;/span> &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>) &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">base&lt;/span>;
&lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#a6e22e">deg&lt;/span> &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>) &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#a6e22e">deg&lt;/span> &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>) &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">base&lt;/span>;
&lt;span style="color:#66d9ef">if&lt;/span> (isNaN(&lt;span style="color:#a6e22e">base&lt;/span>) &lt;span style="color:#f92672">||&lt;/span> isNaN(&lt;span style="color:#a6e22e">deg&lt;/span>)) &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">NaN&lt;/span>;
&lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">!&lt;/span>isFinite(&lt;span style="color:#a6e22e">base&lt;/span>) &lt;span style="color:#f92672">||&lt;/span> &lt;span style="color:#f92672">!&lt;/span>isFinite(&lt;span style="color:#a6e22e">deg&lt;/span>)) &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">Infinity&lt;/span>;
&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">p&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">i&lt;/span>&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>;&lt;span style="color:#a6e22e">i&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#a6e22e">deg&lt;/span>;&lt;span style="color:#a6e22e">i&lt;/span>&lt;span style="color:#f92672">++&lt;/span>){
&lt;span style="color:#a6e22e">p&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">p&lt;/span>&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">base&lt;/span>
}
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">p&lt;/span>;
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Chúng ta đã implement một hàm luỹ thừa manually mà không dựa vào thư viện. Tuy vậy, thực sự thì hàm luỹ thừa này vẫn còn thiếu sót rất nhiều, cụ thể hơn &lt;strong>Nếu số mũ của chúng ta số thực thì sao?&lt;/strong> Hàm &lt;code>pow&lt;/code> được cài đặt ở trên lại không thể giúp chúng ta, vì chúng ta không thể lặp &amp;ldquo;số thực&amp;rdquo; lần được.&lt;/p>
&lt;h1 id="logarithms">Logarithms&lt;/h1>
&lt;p>Cái gì cũng có mặt trái của nó, (chỉ có bản mặt của tôi là không có người yêu), ngoại trừ phép &lt;strong>power&lt;/strong> thì chúng ta còn có phép toán &lt;strong>logarithm&lt;/strong>. Phép toán &lt;strong>logarithm&lt;/strong> giúp chúng ta tìm được &lt;strong>exponent&lt;/strong> của một số. Tuy nhiên dựa vào những kiến thức hạn hẹp của tôi về toán và cả lập trình thì tôi chưa nghĩ ra cách nào để cài đặt hàm &lt;strong>logarithm&lt;/strong> bằng vòng lặp đơn giản như phép luỹ thừa vậy. Chúng ta hãy tìm hiểu một chút về phép &lt;strong>logarithm&lt;/strong> và &lt;strong>e&lt;/strong> - magical number. &lt;strong>Logarithm&lt;/strong> là &lt;strong>inverse function&lt;/strong> của &lt;strong>exponential function&lt;/strong>.
&lt;figure style="flex-grow: 100; flex-basis: 240px">
&lt;a href="https://sonlhcsuit.github.io/p/power/exponential-vs-logarithm.png" data-size="400x400">&lt;img src="https://sonlhcsuit.github.io/p/power/exponential-vs-logarithm.png"
srcset="https://sonlhcsuit.github.io/p/power/exponential-vs-logarithm_hu2c9c07d75c824bc0b770b22fad5f68c4_21074_480x0_resize_box_3.png 480w, https://sonlhcsuit.github.io/p/power/exponential-vs-logarithm_hu2c9c07d75c824bc0b770b22fad5f68c4_21074_1024x0_resize_box_3.png 1024w"
width="400"
height="400"
loading="lazy"
alt="Exponential vs logarithm">
&lt;/a>
&lt;figcaption>Exponential vs logarithm&lt;/figcaption>
&lt;/figure>
$$
a^n = b \newline
\log_a b = n
$$&lt;/p>
&lt;p>Nhìn vào công thức quen thuộc này thì chúng ta có thể nhận ra rằng là, nếu chúng ta biết cách tính hàm &lt;strong>logarithm&lt;/strong> thì mọi chuyện sẽ trở nên dễ dàng khi tìm bậc luỹ thừa. Nhưng mà mọi chuyện đâu có dễ như vậy, bởi vì chúng ta đang giậm chân tại chỗ ở hàm &lt;code>pow&lt;/code> hiện tại (chỉ có thể tính được nếu bậc luỹ thừa là số nguyên), vậy nên &lt;strong>n&lt;/strong> sẽ luôn luôn là số nguyên (với cái cách tính hàm &lt;code>pow&lt;/code> ở trên đã được mình đề ra). Chúng ta cần một cách tính khác có thể giúp chúng ta tính được &lt;code>pow&lt;/code> với bậc luỹ thừa là số thực. Thứ giúp chúng ta làm được việc là &lt;strong>e&lt;/strong>, và &lt;strong>calculus&lt;/strong>.&lt;/p>
&lt;h1 id="magical-number">Magical number&lt;/h1>
&lt;p>Tầm quan trọng của &lt;strong>e&lt;/strong> trong giải tích thì không ai phải bàn cãi, nó thực sự rất là quan trọng luôn (quan trọng tới mức tôi không thể sống thiếu e). &lt;strong>Vậy e được tìm ra như thế nào và ý nghĩa của e là gì?&lt;/strong> Để làm rõ vấn đề này thì chúng ta sẽ nói về &lt;strong>growth&lt;/strong> - sự tăng trưởng. Chúng ta sẽ lấy ví dụ về &lt;strong>compound interest&lt;/strong> để dễ hình dung hơn về &lt;strong>growth&lt;/strong>. Đặc biệt khi tính toán lãi kép thì đơn vị thời gian chúng ta sử dụng là số nguyên với đơn vị thời gian. Chúng ta hãy tìm hiểu một tí, &lt;strong>e là gì và tại sao e lại đặc biệt như vậy?&lt;/strong>&lt;/p>
&lt;p>$$
A = P(1 + \frac{r} {n})^{nt}
$$&lt;/p>
&lt;ul>
&lt;li>A: Số tiền cuối cùng bạn nhận được&lt;/li>
&lt;li>P: Số tiền ban đầu&lt;/li>
&lt;li>r: Tỉ lệ lãi&lt;/li>
&lt;li>n: Số lần áp dụng lãi kép ()&lt;/li>
&lt;li>t: Thời gian một chu kỳ (áp dụng lãi kép)&lt;/li>
&lt;/ul>
&lt;p>Chúng ta sẽ bắt đầu với&lt;/p>
&lt;ul>
&lt;li>P: 1 ($)&lt;/li>
&lt;li>r: 1 (100%)&lt;/li>
&lt;li>n: 3 (lần)&lt;/li>
&lt;li>t: 1 (năm)&lt;/li>
&lt;/ul>
&lt;p>&lt;figure style="flex-grow: 231; flex-basis: 556px">
&lt;a href="https://sonlhcsuit.github.io/p/power/compound-interest-1.png" data-size="1252x540">&lt;img src="https://sonlhcsuit.github.io/p/power/compound-interest-1.png"
srcset="https://sonlhcsuit.github.io/p/power/compound-interest-1_hu22ed96f3d00453168bbba9e05e1fe877_30347_480x0_resize_box_3.png 480w, https://sonlhcsuit.github.io/p/power/compound-interest-1_hu22ed96f3d00453168bbba9e05e1fe877_30347_1024x0_resize_box_3.png 1024w"
width="1252"
height="540"
loading="lazy"
alt="100% interest per year">
&lt;/a>
&lt;figcaption>100% interest per year&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>Nhìn qua hình này ta có thể nhận ra đây vừa là ví dụ của lãi kép, và vừa là ví dụ power 2 với số mũ là số tự nhiên. Tới đây thì chúng ta sẽ bắt đầu chia số mũ thành từng đoạn nhỏ. Chúng ta thay đổi chu kỳ từ 1 năm thành 6 tháng (hoặc 3) tháng và đồng thời chia nhỏ lãi (thay ví 100% cho 1 năm thì sẽ là 50%/6 tháng và 25%/ 3 tháng) kết quả sẽ như sau:&lt;/p>
&lt;p>&lt;figure style="flex-grow: 275; flex-basis: 661px">
&lt;a href="https://sonlhcsuit.github.io/p/power/compound-interest-2.png" data-size="1252x454">&lt;img src="https://sonlhcsuit.github.io/p/power/compound-interest-2.png"
srcset="https://sonlhcsuit.github.io/p/power/compound-interest-2_hub2145894df599da842835cae85efcb0f_28691_480x0_resize_box_3.png 480w, https://sonlhcsuit.github.io/p/power/compound-interest-2_hub2145894df599da842835cae85efcb0f_28691_1024x0_resize_box_3.png 1024w"
width="1252"
height="454"
loading="lazy"
alt="50% interest per 6 month">
&lt;/a>
&lt;figcaption>50% interest per 6 month&lt;/figcaption>
&lt;/figure>
&lt;figure style="flex-grow: 342; flex-basis: 820px">
&lt;a href="https://sonlhcsuit.github.io/p/power/compound-interest-3.png" data-size="1512x442">&lt;img src="https://sonlhcsuit.github.io/p/power/compound-interest-3.png"
srcset="https://sonlhcsuit.github.io/p/power/compound-interest-3_hu36a51863d3314e4978780a64e783b1b7_36247_480x0_resize_box_3.png 480w, https://sonlhcsuit.github.io/p/power/compound-interest-3_hu36a51863d3314e4978780a64e783b1b7_36247_1024x0_resize_box_3.png 1024w"
width="1512"
height="442"
loading="lazy"
alt="25% interest per 3 month">
&lt;/a>
&lt;figcaption>25% interest per 3 month&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>Vậy khi chúng ta chia lãi càng nhỏ (tới mức $10^{-9}$), thì chúng ta sẽ đạt được &lt;strong>growth&lt;/strong> càng lớn, giá trị này hội tụ lại tại &lt;strong>e = 2.71828&amp;hellip;&lt;/strong>( ~171% rate per year). &lt;strong>e&lt;/strong> được gọi với cái tên: con số của sự tăng tưởng. &lt;strong>e&lt;/strong> là kết quả lớn nhất có thể khi áp dụng &lt;strong>lãi kép liên tục&lt;/strong> ở mức lãi 100% sau một đơn vị thời gian (lãi kép liên tục là việc chia nhỏ lãi đến mức không thể nhỏ hơn). Và hàm $f(x) = e^x$ được gọi là hàm mũ tự nhiên (The natural exponential function). Một điều tuyệt vời rằng giá trị của $f'(x) = e^x$. Một hàm tuyệt vời. Đây là hàm duy nhất tại thời điểm hiện tại có tính chất này. Thực hiện phép log với cơ số e: $\log_e x$, được gọi là &lt;strong>natural logarithm&lt;/strong>.&lt;/p>
&lt;h1 id="real-exponent">Real exponent&lt;/h1>
&lt;p>Làm sao để tính $a^b$ với b là số thực? Chúng ta sẽ cần tới phép &lt;strong>natural logarithm&lt;/strong>, cơ số &lt;strong>a&lt;/strong> ta có thể biểu diễn dưới dạng $e^x$ và natural logarithm như sau
$$
e^a = b \newline \log_e b = a \newline \rightarrow b = e^{\ln b}
$$&lt;/p>
&lt;p>$$
a^b = (e^{\ln a})^{b} \leftrightarrow a^b = e^{b\ln a}
$$&lt;/p>
&lt;p>Có vẻ tới đây thì chúng ta sẽ tính $ e^{b\ln a}$ để có được kết quả của $a^b$ với b là số thực. Nhưng chúng ta lại gặp vấn đề: $\ln a$ có thể là số thực, và chúng ta lại quay vào vòng lẩn quẩn. Tuy nhiên ta có thể giải quyết vấn đề này nếu như cơ số là e (why it is magical) bằng công thức sau (Khai triển Taylor đối với chuỗi luỹ thừa - nhờ vào tính chất $f'(x) = e^x$ nên chúng ta mới có công thức này):&lt;/p>
&lt;p>$$
e^x = \sum_{k=0}^{\infin} \frac{x^k} {k!}
$$&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">exp&lt;/span>(&lt;span style="color:#a6e22e">x&lt;/span>) {
&lt;span style="color:#75715e">// depend ons how many accuracy, we need to specific fixed K, in this example
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">k&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">50&lt;/span>;
&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">factorial&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">exponent&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">sum&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">i&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>; &lt;span style="color:#a6e22e">i&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span> &lt;span style="color:#a6e22e">k&lt;/span>; &lt;span style="color:#a6e22e">i&lt;/span>&lt;span style="color:#f92672">++&lt;/span>) {
&lt;span style="color:#a6e22e">exponent&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">exponent&lt;/span> &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#a6e22e">x&lt;/span>;
&lt;span style="color:#a6e22e">factorial&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">factorial&lt;/span> &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#a6e22e">i&lt;/span>
&lt;span style="color:#a6e22e">sum&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">sum&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#a6e22e">exponent&lt;/span> &lt;span style="color:#f92672">/&lt;/span> &lt;span style="color:#a6e22e">factorial&lt;/span>;
}
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">sum&lt;/span>
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Và bây giờ chúng ta tiếp tục hoàn hiện hàm $\ln a$. Theo lý thuyết thì $\ln a$ được định nghĩa là phần diện tích phía dưới đường cong&lt;/p>
&lt;p>&lt;figure style="flex-grow: 199; flex-basis: 479px">
&lt;a href="https://sonlhcsuit.github.io/p/power/lna.png" data-size="2880x1442">&lt;img src="https://sonlhcsuit.github.io/p/power/lna.png"
srcset="https://sonlhcsuit.github.io/p/power/lna_hu455af0b932974b572a26e22dddb95edb_72211_480x0_resize_box_3.png 480w, https://sonlhcsuit.github.io/p/power/lna_hu455af0b932974b572a26e22dddb95edb_72211_1024x0_resize_box_3.png 1024w"
width="2880"
height="1442"
loading="lazy"
alt="ln a - the definition">
&lt;/a>
&lt;figcaption>ln a - the definition&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>$$
\ln a = \int_{1}^{a} \frac{1} {x} \frac{d} {dx}
$$&lt;/p>
&lt;p>Và làm sao chúng ta tính được nó khi nguyên hàm của $\int \frac{1} {x} = \ln|x| + C$. Lại một vòng lẩn quẩn mới chăng? Thực ra là chúng ta sẽ dùng cả kiến thức về chuỗi luỹ thừa, khai triển &lt;strong>Taylor&lt;/strong> nữa,p hương pháp &lt;strong>tích phân từng phần&lt;/strong>, &amp;hellip; Kết quả như sau:&lt;/p>
&lt;p>$$
\ln a = - \ln (1-x) = \sum_k^\infin \frac{x^k} {k} \newline
a = \frac {1} {1-x} \newline
\forall a &amp;gt; 1
$$&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">ln_upper&lt;/span>(&lt;span style="color:#a6e22e">a&lt;/span>) {
&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">k&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">50&lt;/span>;
&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">x&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#f92672">/&lt;/span> &lt;span style="color:#a6e22e">a&lt;/span>;
&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">sum&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">exponent&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">i&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>; &lt;span style="color:#a6e22e">i&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span> &lt;span style="color:#a6e22e">k&lt;/span>; &lt;span style="color:#a6e22e">i&lt;/span>&lt;span style="color:#f92672">++&lt;/span>) {
&lt;span style="color:#a6e22e">exponent&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">exponent&lt;/span> &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#a6e22e">x&lt;/span>;
&lt;span style="color:#a6e22e">sum&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">sum&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#a6e22e">exponent&lt;/span> &lt;span style="color:#f92672">/&lt;/span> &lt;span style="color:#a6e22e">i&lt;/span>
}
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">sum&lt;/span>
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Còn đây là đối với $a \le 1$&lt;/p>
&lt;p>&lt;figure style="flex-grow: 213; flex-basis: 511px">
&lt;a href="https://sonlhcsuit.github.io/p/power/lna-proven.png" data-size="2038x956">&lt;img src="https://sonlhcsuit.github.io/p/power/lna-proven.png"
srcset="https://sonlhcsuit.github.io/p/power/lna-proven_hu9e5ee3e7b34ab1644ea84e2afe1ca980_168408_480x0_resize_box_3.png 480w, https://sonlhcsuit.github.io/p/power/lna-proven_hu9e5ee3e7b34ab1644ea84e2afe1ca980_168408_1024x0_resize_box_3.png 1024w"
width="2038"
height="956"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">ln_lower&lt;/span>(&lt;span style="color:#a6e22e">a&lt;/span>) {
&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">k&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">50&lt;/span>;
&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">u&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">a&lt;/span> &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">sum&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">exponent&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">i&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>; &lt;span style="color:#a6e22e">i&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span> &lt;span style="color:#a6e22e">k&lt;/span>; &lt;span style="color:#a6e22e">i&lt;/span>&lt;span style="color:#f92672">++&lt;/span>) {
&lt;span style="color:#a6e22e">exponent&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">exponent&lt;/span> &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#a6e22e">u&lt;/span>;
&lt;span style="color:#a6e22e">sum&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">sum&lt;/span> &lt;span style="color:#f92672">+&lt;/span> (&lt;span style="color:#a6e22e">i&lt;/span> &lt;span style="color:#f92672">%&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span> &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#f92672">?&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>) &lt;span style="color:#f92672">*&lt;/span>( &lt;span style="color:#a6e22e">exponent&lt;/span> &lt;span style="color:#f92672">/&lt;/span> &lt;span style="color:#a6e22e">i&lt;/span>)
}
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">sum&lt;/span>
}
&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">exp&lt;/span>(&lt;span style="color:#a6e22e">x&lt;/span>) {
&lt;span style="color:#75715e">// depend ons how many accuracy, we need to specific fixed K, in this example
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">k&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">50&lt;/span>;
&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">factorial&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">exponent&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">sum&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">i&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>; &lt;span style="color:#a6e22e">i&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span> &lt;span style="color:#a6e22e">k&lt;/span>; &lt;span style="color:#a6e22e">i&lt;/span>&lt;span style="color:#f92672">++&lt;/span>) {
&lt;span style="color:#a6e22e">exponent&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">exponent&lt;/span> &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#a6e22e">x&lt;/span>;
&lt;span style="color:#a6e22e">factorial&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">factorial&lt;/span> &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#a6e22e">i&lt;/span>
&lt;span style="color:#a6e22e">sum&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">sum&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#a6e22e">exponent&lt;/span> &lt;span style="color:#f92672">/&lt;/span> &lt;span style="color:#a6e22e">factorial&lt;/span>;
}
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">sum&lt;/span>
}
&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">ln_upper&lt;/span>(&lt;span style="color:#a6e22e">a&lt;/span>) {
&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">k&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">50&lt;/span>;
&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">x&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#f92672">/&lt;/span> &lt;span style="color:#a6e22e">a&lt;/span>;
&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">sum&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">exponent&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">i&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>; &lt;span style="color:#a6e22e">i&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span> &lt;span style="color:#a6e22e">k&lt;/span>; &lt;span style="color:#a6e22e">i&lt;/span>&lt;span style="color:#f92672">++&lt;/span>) {
&lt;span style="color:#a6e22e">exponent&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">exponent&lt;/span> &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#a6e22e">x&lt;/span>;
&lt;span style="color:#a6e22e">sum&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">sum&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#a6e22e">exponent&lt;/span> &lt;span style="color:#f92672">/&lt;/span> &lt;span style="color:#a6e22e">i&lt;/span>
}
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">sum&lt;/span>
}
&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">ln_lower&lt;/span>(&lt;span style="color:#a6e22e">a&lt;/span>) {
&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">k&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">50&lt;/span>;
&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">u&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">a&lt;/span> &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">sum&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">exponent&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">i&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>; &lt;span style="color:#a6e22e">i&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span> &lt;span style="color:#a6e22e">k&lt;/span>; &lt;span style="color:#a6e22e">i&lt;/span>&lt;span style="color:#f92672">++&lt;/span>) {
&lt;span style="color:#a6e22e">exponent&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">exponent&lt;/span> &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#a6e22e">u&lt;/span>;
&lt;span style="color:#a6e22e">sum&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">sum&lt;/span> &lt;span style="color:#f92672">+&lt;/span> (&lt;span style="color:#a6e22e">i&lt;/span> &lt;span style="color:#f92672">%&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span> &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#f92672">?&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>) &lt;span style="color:#f92672">*&lt;/span> (&lt;span style="color:#a6e22e">exponent&lt;/span> &lt;span style="color:#f92672">/&lt;/span> &lt;span style="color:#a6e22e">i&lt;/span>)
}
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">sum&lt;/span>
}
&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">ln&lt;/span>(&lt;span style="color:#a6e22e">a&lt;/span>){
&lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#a6e22e">a&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>) &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">NaN&lt;/span>
&lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#a6e22e">a&lt;/span>&lt;span style="color:#f92672">&amp;lt;=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>) &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">ln_lower&lt;/span>(&lt;span style="color:#a6e22e">a&lt;/span>);
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">ln_upper&lt;/span>(&lt;span style="color:#a6e22e">a&lt;/span>)
}
&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">pow&lt;/span>(&lt;span style="color:#a6e22e">base&lt;/span>,&lt;span style="color:#a6e22e">deg&lt;/span>){
&lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#a6e22e">base&lt;/span> &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#f92672">||&lt;/span> &lt;span style="color:#a6e22e">base&lt;/span> &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>) &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">base&lt;/span>;
&lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#a6e22e">deg&lt;/span> &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>) &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#a6e22e">deg&lt;/span> &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>) &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">base&lt;/span>;
&lt;span style="color:#66d9ef">if&lt;/span> (isNaN(&lt;span style="color:#a6e22e">base&lt;/span>) &lt;span style="color:#f92672">||&lt;/span> isNaN(&lt;span style="color:#a6e22e">deg&lt;/span>)) &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">NaN&lt;/span>;
&lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">!&lt;/span>isFinite(&lt;span style="color:#a6e22e">base&lt;/span>) &lt;span style="color:#f92672">||&lt;/span> &lt;span style="color:#f92672">!&lt;/span>isFinite(&lt;span style="color:#a6e22e">deg&lt;/span>)) &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">Infinity&lt;/span>;
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">exp&lt;/span>(&lt;span style="color:#a6e22e">deg&lt;/span>&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">ln&lt;/span>(&lt;span style="color:#a6e22e">base&lt;/span>));
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Tới đoạn này thì việc cài đặt một hàm trông có vẻ nhỏ như con thỏ, nhưng lại tốn rất nhiều chất xám, và khó khăn khi cài đặt. Chúng ta đã làm được việc đó rồi. (Ít nhất thì độ chính xác của chúng ta chưa cần thiết quá cao khi nói về các kiến trúc mạng)&lt;/p>
&lt;hr>
&lt;h1 id="references--more-resources">References &amp;amp; more resources&lt;/h1>
&lt;ul>
&lt;li>&lt;a class="link" href="https://www.youtube.com/watch?v=AuA2EAgAegE" target="_blank" rel="noopener"
>https://www.youtube.com/watch?v=AuA2EAgAegE&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://www.youtube.com/watch?v=_-x90wGBD8U" target="_blank" rel="noopener"
>https://www.youtube.com/watch?v=_-x90wGBD8U&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://en.wikipedia.org/wiki/E_%28mathematical_constant%29" target="_blank" rel="noopener"
>https://en.wikipedia.org/wiki/E_(mathematical_constant)&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://en.wikipedia.org/wiki/Exponential_function" target="_blank" rel="noopener"
>https://en.wikipedia.org/wiki/Exponential_function&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://en.wikipedia.org/wiki/Natural_logarithm" target="_blank" rel="noopener"
>https://en.wikipedia.org/wiki/Natural_logarithm&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://math.stackexchange.com/questions/635787/how-to-calculate-lnx" target="_blank" rel="noopener"
>https://math.stackexchange.com/questions/635787/how-to-calculate-lnx&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://stackoverflow.com/questions/9799041/efficient-implementation-of-natural-logarithm-ln-and-exponentiation/63773160#63773160" target="_blank" rel="noopener"
>https://stackoverflow.com/questions/9799041/efficient-implementation-of-natural-logarithm-ln-and-exponentiation/63773160#63773160&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://www.netlib.org/fdlibm/e_pow.c" target="_blank" rel="noopener"
>https://www.netlib.org/fdlibm/e_pow.c&lt;/a>&lt;/li>
&lt;/ul>
&lt;h3 id="ps">P/S:&lt;/h3>
&lt;p>Nếu có gì sai sót xin gửi email cho mình để cập nhật, xin cảm ơn!&lt;/p></description></item><item><title>Programming Language History Overview</title><link>https://sonlhcsuit.github.io/p/programming-language-overview/</link><pubDate>Tue, 04 May 2021 08:21:25 +0700</pubDate><guid>https://sonlhcsuit.github.io/p/programming-language-overview/</guid><description>&lt;img src="https://sonlhcsuit.github.io/p/programming-language-overview/cover.png" alt="Featured image of post Programming Language History Overview" />&lt;h1 id="history-about-programming-languages--computer">History about Programming Languages &amp;amp; Computer&lt;/h1>
&lt;p>Chúng ta có thể khái quát lịch sử máy tính bằng bài viết khác, nhưng sau thời gian dài phát triển, thì công dụng chủ yếu của máy tính là để tính toán dựa trên &lt;em>input&lt;/em> và sinh ra &lt;em>output&lt;/em>. Máy tính ở thời điểm ban đầu có kích thước rất to (lớn hơn $100 m^2$), vật đổi sao dời khiến kích thước máy tính giảm dần bởi &lt;strong>CPU&lt;/strong> (&lt;em>Central Processing Unit&lt;/em>) - lõi của máy tính càng ngày càng nhỏ dựa vào công nghệ &lt;em>nano&lt;/em>. Thời điểm ban đầu, &lt;strong>CPU&lt;/strong> được chế tạo dựa trên bóng đèn dây tóc - biểu thị trạng thái bật (số 0) và tắt (số 1). Công nghệ phát triển giúp chúng ta thay thế bóng đèn bằng bóng bán dẫn nhỏ hơn bóng đèn cả nghìn lần. Nhờ vào việc thay đổi sử dụng &lt;em>transistor&lt;/em> (bóng bán dẫn) vào việc chế tạo, khiến cho kích thước &lt;strong>CPU&lt;/strong> càng ngày càng nhỏ (dẫn tới hệ quả là kích thước máy tính nhỏ dần). Một định luật có tên là &lt;strong>Moore&lt;/strong> phát biểu rằng, cứ sau một chu kỳ thời gian nhất định thì số lượng &lt;em>transistor&lt;/em> trên một đơn vị diện tích ( $cm^2$ ) sẽ tăng gấp đôi. Công nghệ &lt;em>nano&lt;/em> còn có nhiều không gian để phát triển, chu kỳ của &lt;strong>Moore&amp;rsquo;s Law&lt;/strong> là 2 năm (Đến thời gian hiện tại thì mình không dám chắc vì không biết rõ là công nghệ nano có thể đạt tới kích thước bao nhiêu. Theo thông tin tham khảo thì 1 &lt;em>transistor&lt;/em> đạt kích thước 0.2 nanometer - $10^{-9}$ meter). Bởi vì lí do chỉ có thể sử dụng 2 trạng thái on/off (cho dòng điện chạy qua) của một bóng đèn / &lt;em>transistor&lt;/em> nên máy tính chỉ hiểu được số nhị phân. Kết hợp các &lt;em>transistor&lt;/em> và các mạch &lt;strong>logic&lt;/strong> khiến cho &lt;strong>CPU&lt;/strong> có thể thực hiện việc tính toán. Và &lt;strong>computer&lt;/strong> được gọi là bởi &lt;strong>computer&lt;/strong> bởi vì được sinh ra với mục đích là &lt;strong>compute&lt;/strong>.&lt;/p>
&lt;p>&lt;figure style="flex-grow: 129; flex-basis: 311px">
&lt;a href="https://sonlhcsuit.github.io/p/programming-language-overview/image-1.png" data-size="700x540">&lt;img src="https://sonlhcsuit.github.io/p/programming-language-overview/image-1.png"
srcset="https://sonlhcsuit.github.io/p/programming-language-overview/image-1_hu75cd8774cd27f766d21d6d55373d0054_18807_480x0_resize_box_3.png 480w, https://sonlhcsuit.github.io/p/programming-language-overview/image-1_hu75cd8774cd27f766d21d6d55373d0054_18807_1024x0_resize_box_3.png 1024w"
width="700"
height="540"
loading="lazy"
alt="Block Diagram of Computer">
&lt;/a>
&lt;figcaption>Block Diagram of Computer&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>&lt;strong>CPU&lt;/strong> của máy tính được dựa trên những thành phần cơ bản gồm &lt;strong>ALU&lt;/strong> (&lt;em>Arithmetic &amp;amp; Logic Unit&lt;/em> - Bộ xử lý tính toán), &lt;strong>Main Memory&lt;/strong> (Bộ nhớ chính), &lt;strong>CU&lt;/strong> (&lt;strong>Control Unit&lt;/strong> - Bộ điều khiển) và các thành phần khác như &lt;em>cache&lt;/em>, &lt;em>register&lt;/em>, et cetera. Chúng ta khiến &lt;strong>computer&lt;/strong> thực hiện tác vụ bằng việc sử dụng &lt;strong>instructions set&lt;/strong> ( bộ lệnh) phù hợp đã được định nghĩa sẵn bởi mỗi nhà thiết kế máy tính. Mỗi máy tính có một đặc điểm khác nhau về việc thiết kế kiến trúc, thiết kế của ALU khác nhau (cùng 1 việc thực hiện phép toán + nhưng có nhiều cách) dẫn tới việc &lt;strong>instructions set&lt;/strong> cũng khác nhau. &lt;em>Developer/scientist&lt;/em> thực hiện công việc xây dựng các chương trình hằng ngày bằng việc sử dụng &lt;strong>instructions set&lt;/strong> bằng mã nhị phân. Điểm yếu của phương pháp này là &lt;strong>chương trình viết trên một máy tính sẽ không chạy trên máy tính khác kiến trúc&lt;/strong>.&lt;/p>
&lt;p>Các &lt;strong>instructions set&lt;/strong> này còn được gọi là &lt;strong>machine language/binary language&lt;/strong>, đây là loại ngôn ngữ lập trình sơ khai nhất. &lt;strong>Programming Language&lt;/strong> (ngôn ngữ lập trình) được tạo ra bởi con người, được sử dụng nhằm mục đích giao tiếp với máy tính, khiến cho máy tính thực hiện các hành vi do người dùng (&lt;strong>developer/scientist&lt;/strong>) chỉ định.&lt;/p>
&lt;h1 id="classification-of-programming-language">Classification of Programming Language&lt;/h1>
&lt;p>Có rất nhiều cách để phân loại ngôn ngữ lập trình dựa trên nhiều tiêu chí. Một tiêu chí hay dùng nhất là dựa trên độ khó của việc viết: &lt;strong>low-level&lt;/strong> &amp;amp; &lt;strong>high-level&lt;/strong>, và nhiều tiêu chí khác, ta có thể loại sơ bộ nhất như sau :&lt;/p>
&lt;ul>
&lt;li>low-level:
&lt;ul>
&lt;li>machine langugage&lt;/li>
&lt;li>assembly language&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>high-level: gồm các paradigm sau.
&lt;ul>
&lt;li>structural language&lt;/li>
&lt;li>procedural language&lt;/li>
&lt;li>object oriented language&lt;/li>
&lt;li>functional language&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>Ưu điểm của ngôn ngữ &lt;strong>low-level&lt;/strong> rất rõ ràng: siêu nhanh, chạy trực tiếp trên &lt;strong>CPU&lt;/strong>. Tuy nhiên yếu điểm cũng không kém cạnh: chỉ gồm bit 0 hoặc 1 (&lt;strong>machine code&lt;/strong>) siêu khó đọc, siêu khó viết, dể ẩn tàng lỗi, siêu khó bảo trì. Một điểm mạnh để thay thế yếu điểm của &lt;strong>assembly code&lt;/strong> so với &lt;strong>machine code&lt;/strong> là có thể sử dụng &lt;strong>english word&lt;/strong> (dễ nhớ) cải thiện code đáng kể, tuy nhiên thì vẫn phải làm việc với 0 và 1. Dù cải thiện nhiều yếu điểm, nhưng thực sự vẫn khó bắt đầu lập trình, và đặc biệt là không có cấu trúc rõ ràng, chỉ gồm một &lt;strong>list instructions&lt;/strong>. Yêu cầu cần &lt;strong>assembler&lt;/strong> để phiên dịch &lt;strong>assembly code&lt;/strong> thành &lt;strong>machine code&lt;/strong>. Tuy nhiên vẫn cần &lt;strong>assembler&lt;/strong> khác nhau dành cho mỗi máy tính kiến trúc khác nhau.&lt;/p>
&lt;p>Ưu của của ngôn ngữ &lt;strong>high-level&lt;/strong> thì không cần ai phải bàn cãi: viết code một lần, dễ đọc, dễ hiểu, dễ debug (ít nhất là so với &lt;strong>assembly&lt;/strong>), có thể chạy ở hầu hết loại máy tính. Câu lệnh tiếng anh rất dễ đọc và dễ viết, cung cấp khả năng trừu tượng. Yếu điểm là phải cần một &lt;strong>compiler/interpreter&lt;/strong> khác nhau cho mỗi loại máy tính. Điều cần phải củng cố &lt;strong>compiler/interpreter&lt;/strong> cho từng loại kiến trúc (x86,et cetera). Ưu điểm rất là rõ ràng, và đa phần &lt;strong>developer&lt;/strong> sử dụng &lt;strong>high-level language&lt;/strong> nên việc phân loại tiếp theo sẽ tập trung vào các &lt;strong>high-level language&lt;/strong>. Lưu ý việc phân loại ở đây, không phải là phân loại từng ngôn ngữ lập trình mà là phân loại các &lt;strong>paradigm&lt;/strong> (mô hình ngôn ngữ lập trình).&lt;/p>
&lt;h1 id="structural-programming--procedural-programming">Structural Programming &amp;amp; Procedural Programming&lt;/h1>
&lt;p>&lt;strong>Structured Programming&lt;/strong> nghĩa là lập trình có cấu trúc, vậy thế nào là có cấu trúc? &amp;ldquo;Cấu trúc&amp;rdquo; ở đây nói về việc xử lý các dòng code một cách hợp lý bằng việc hỗ trợ thêm các khái niệm như: &lt;em>blocks&lt;/em>/&lt;em>scopes&lt;/em>, &lt;em>control flows&lt;/em> (&lt;em>condition&lt;/em> &amp;amp; &lt;em>repitition&lt;/em>), &lt;em>subroutines&lt;/em>. Tại sao lại hỗ trợ thêm các khái niệm này? Trước khi các khái niệm này sinh ra thì đa phần các chương trình đều viết bằng assembly nên việc sử dụng câu lệnh jump/goto là cực kỳ phổ biến. Hãy xem xét ví dụ về việc rẽ nhánh và lặp sau đây.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-asm" data-lang="asm">&lt;span style="color:#a6e22e">mov&lt;/span> &lt;span style="color:#66d9ef">eax&lt;/span>,&lt;span style="color:#ae81ff">1&lt;/span>
&lt;span style="color:#a6e22e">cmp&lt;/span> &lt;span style="color:#66d9ef">eax&lt;/span>,&lt;span style="color:#ae81ff">3&lt;/span> &lt;span style="color:#75715e">; how does eax compare with 3?
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">jl&lt;/span> &lt;span style="color:#66d9ef">lemme_outta_here&lt;/span> &lt;span style="color:#75715e">; if it&amp;#39;s less, then jump
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">mov&lt;/span> &lt;span style="color:#66d9ef">eax&lt;/span>,&lt;span style="color:#ae81ff">999&lt;/span> &lt;span style="color:#75715e">; &amp;lt;- not executed *if* we jump over it
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">lemme_outta_here&lt;/span>:
&lt;span style="color:#a6e22e">ret&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-asm" data-lang="asm">&lt;span style="color:#a6e22e">mov&lt;/span> &lt;span style="color:#66d9ef">eax&lt;/span>,&lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#75715e">; sum added here
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">mov&lt;/span> &lt;span style="color:#66d9ef">edi&lt;/span>,&lt;span style="color:#ae81ff">4&lt;/span>
start: &lt;span style="color:#75715e">; loop begins here
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#a6e22e">add&lt;/span> &lt;span style="color:#66d9ef">eax&lt;/span>,&lt;span style="color:#ae81ff">10&lt;/span> &lt;span style="color:#75715e">; add each time around the loop
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">sub&lt;/span> &lt;span style="color:#66d9ef">edi&lt;/span>,&lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#75715e">; loop increment
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">cmp&lt;/span> &lt;span style="color:#66d9ef">edi&lt;/span>,&lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#75715e">; loop test
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">jg&lt;/span> &lt;span style="color:#66d9ef">start&lt;/span> &lt;span style="color:#75715e">; continue loop if edi&amp;gt;0
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#a6e22e">ret&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Nhìn vào 2 ví dụ trên thì mọi chuyện không khác biệt, nếu bạn đã cố gắng hiểu những dòng &lt;em>comment&lt;/em>. Tuy nhiên, khi debug &lt;em>assembly code&lt;/em> thì thực sự là một cực hình (ít nhất thì mình có từng chạy &lt;em>code assembly&lt;/em> khi học Computer Architecture - Kiến trúc máy tính), đặc biệt là phải soi rất kỹ lệnh &lt;code>cmp&lt;/code> và lệnh &lt;code>jump&lt;/code> các loại, đồng thời còn quan sát từng label nữa. Việc sử dụng câu lệnh goto sẽ khiến cho code chúng ta được tối ưu (không gian dòng lệnh, chức năng, tốc độ, et cetera) nhưng lại mang đến một hậu quả kinh khủng là cực hình khi debug (nhìn nhầm 1 dòng là không biết &lt;em>instructions pointer&lt;/em> chạy đi đâu luôn). Để giải quyết vấn đề này thì một vài khái niệm đã xuất hiện giúp cho cuộc sống của các lập trình viên dễ dàng hơn bằng việc hỗ trợ thêm khái niệm scopes / control flows giúp code dễ đọc hơn khi phải thực hiện các thao tác như so sánh, lặp, hàm, et cetera. Hỗ trợ thêm nhiều từ khoá giúp con người dễ dàng làm quen hơn.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-cxx" data-lang="cxx">&lt;span style="color:#66d9ef">int&lt;/span> eax &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;span style="color:#66d9ef">if&lt;/span> (eax &lt;span style="color:#f92672">&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">3&lt;/span>){
eax &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">999&lt;/span>;
}
&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-cxx" data-lang="cxx">&lt;span style="color:#66d9ef">int&lt;/span> eax &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;span style="color:#66d9ef">int&lt;/span> edi &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">4&lt;/span>;
&lt;span style="color:#66d9ef">while&lt;/span> (edi &lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>){
eax &lt;span style="color:#f92672">=&lt;/span> eax &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">10&lt;/span>;
edi &lt;span style="color:#f92672">=&lt;/span> edi &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Bàn về &lt;strong>procedural programming&lt;/strong>, cơ bản là mở rộng sự hỗ trợ của khái niệm &lt;em>subroutines&lt;/em> từ &lt;strong>structured programming&lt;/strong>, đồng thời kế thừa các khái niệm như &lt;em>scope&lt;/em> / &lt;em>control flows&lt;/em> để mở rộng thế giới của &lt;strong>programming language&lt;/strong>, giúp việc viết một chương trình đơn giản hơn. Procedural language sẽ xoay quanh các khái niệm như &lt;code>record&lt;/code>, &lt;code>module&lt;/code>,&lt;code>procedure&lt;/code>, &lt;code>procedure call&lt;/code>. Thuở sơ khai thì &lt;strong>procedural programming&lt;/strong> hỗ trợ cho phép các procedure thực hiện các thao tác thực tiếp lên vùng nhớ, giá trị của các thanh ghi / biến (&lt;code>record&lt;/code>), đồng thời cũng hỗ trợ việc gom nhóm procedure liên quan tới nhau thành nhóm - &lt;code>module&lt;/code> để dễ dàng quản lý, sử dụng ở nhiều nơi. Khi &lt;code>procedure call&lt;/code> được gọi thì &lt;code>instruction pointer&lt;/code> sẽ lập tức di chuyển đến nơi khai báo và thực hiện việc thao tác dựa trên dữ liệu được gọi (thường là địa chỉ của giá trị để thao tác trực tiếp). Sau khi &lt;code>procedural call&lt;/code> kết thúc thì giá trị sẽ được cập nhật ở vị trí cũ và &lt;code>instruction pointer&lt;/code> quay lại nơi được gọi và tiếp tục xử lý các &lt;code>instruction&lt;/code> khác. Điều cần nói ở đây là &lt;strong>procedural programming&lt;/strong> cần phải có sự hỗ trợ từ &lt;strong>structured language&lt;/strong>. &lt;code>procedural&lt;/code> có thể hiểu tương tự như &lt;code>function&lt;/code> (hàm). Tuy nhiên hàm thì thay vì cập nhật trực tiếp giá trị ở ô nhớ thì lại trả về giá trị mới để chúng ta có thể tính toán bước tiếp theo mà không cần phải cập nhật giá trị ở ô nhớ cũ (thường là lưu lại để chuẩn bị tính toán tiếp). Sự khác biệt giữa &lt;code>procedural&lt;/code> &amp;amp; &lt;code>function&lt;/code> đa phần đến từ cách truyền giá trị vào và trả về giá trị.&lt;/p>
&lt;p>Một ngôn ngữ lập trình không nhất thiết chỉ hỗ trợ một &lt;strong>paradigm&lt;/strong>, mà có thể nhiều &lt;strong>paradigm&lt;/strong>. Một ví dụ điển hình hiện tại là phần lớn các ngôn như lập trình bậc cao đều hỗ trợ &lt;strong>structured&lt;/strong> / &lt;strong>procedural language&lt;/strong> (câu lệnh điều khiển và function/procedure). Ví dụ về &lt;strong>pass by value&lt;/strong> &amp;amp; &lt;strong>pass by reference&lt;/strong> là 2 trường hợp để phân biệt rõ nhất về sự khác nhau giữa &lt;strong>function/procedure&lt;/strong> (Nếu không muốn thì cũng không sao cả vì sự khác biệt rất nhỏ). Để phân biệt rõ hơn về 2 khái niệm này thì cần phải tìm hiểu về các thanh ghi &lt;code>callee ($s)&lt;/code> &amp;amp; &lt;code>caller ($t)&lt;/code>, tuy nhiên việc này cũng ít cần thiết nốt, vì đa phần các ngôn ngữ lập trình đã làm thay ta công việc này rồi. Hãy xem xét 2 ví dụ của **C++**sau đây.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-cxx" data-lang="cxx">&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;iostream&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">mean&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> a,&lt;span style="color:#66d9ef">int&lt;/span> b){
&lt;span style="color:#66d9ef">return&lt;/span> (a&lt;span style="color:#f92672">+&lt;/span>b)&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#ae81ff">2&lt;/span>;
}
&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">swap&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#f92672">*&lt;/span>a, &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#f92672">*&lt;/span>b){
&lt;span style="color:#66d9ef">int&lt;/span> t &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">*&lt;/span>a;
&lt;span style="color:#f92672">*&lt;/span>a &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">*&lt;/span>b;
&lt;span style="color:#f92672">*&lt;/span>b &lt;span style="color:#f92672">=&lt;/span> t;
}
&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>(){
&lt;span style="color:#66d9ef">int&lt;/span> a &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">100&lt;/span>;
&lt;span style="color:#66d9ef">int&lt;/span> b &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">21&lt;/span>;
cout &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> mean(a,b) &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>;
swap(&lt;span style="color:#f92672">&amp;amp;&lt;/span>a,&lt;span style="color:#f92672">&amp;amp;&lt;/span>b);
cout &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> a &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span>&lt;span style="color:#e6db74">&amp;#34; &amp;#34;&lt;/span>&lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> b;
}
&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="objet-oriented-programming--functional-programming">Objet Oriented Programming &amp;amp; Functional Programming&lt;/h1>
&lt;p>&lt;strong>Functional Programming&lt;/strong> (lập trình hướng chức năng) là một loại phong cách lập trình, mục đích chủ yếu xoay quanh về việc các &lt;code>function&lt;/code> (chức năng) được hoàn thành như thế nào. Chúng ta chỉ cần đưa vào input vào một chức năng thì sẽ có ngay lập tức output hợp lệ. &lt;strong>Functional Programming&lt;/strong> thường xoay quanh việc áp dụng, tạo ra các function như thế nào. Những function này thường là một dãy các expression (biểu thức) để mapping (ánh xạ, biến đổi, et cetera) dữ liệu đầu vào thành dữ liệu đầu ra (input &amp;amp; output) mà tránh việc dữ liệu bị thay đổi (mutable state), side effects khiến cho code trở trên dễ hiểu, debug, test, et cetera. Javascript có hỗ trợ &lt;strong>Functional Programming&lt;/strong>, tuy nhiên nên tránh nhầm lẫn giữa việc hỗ trợ &lt;strong>Functional Programming&lt;/strong> và thuần &lt;strong>Functional Programming&lt;/strong> (purely &lt;strong>functional programming&lt;/strong> - được kế thừa dựa trên lambda calculus). &lt;strong>Functional Programming&lt;/strong> xem function là &lt;em>first-class citizen&lt;/em>, lưu ý rằng ở đây không mang ý nghĩa phân biệt thượng đẳng/hạ đẳng mà là nhằm mục đích để chỉ rằng tư tưởng của &lt;strong>Functional Programming&lt;/strong> xoay quanh hàm - tức là function sẽ được &lt;em>fully supported&lt;/em>. &lt;strong>Functional Programming&lt;/strong> là một khái niệm rất mới, dần tiếp cận với các lập trình viên từ các framework của Javascript (Hook của React), nhưng những ngôn ngữ &lt;strong>pure functional programming language&lt;/strong> thì lại khá là kén (haskell, lisp, et cetera). Sau đây sẽ là một vài ví dụ về &lt;strong>Functional Programming&lt;/strong> ở trong Javascript.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">array&lt;/span> &lt;span style="color:#f92672">=&lt;/span> [&lt;span style="color:#ae81ff">5&lt;/span>, &lt;span style="color:#ae81ff">19&lt;/span>, &lt;span style="color:#ae81ff">16&lt;/span>, &lt;span style="color:#ae81ff">7&lt;/span>, &lt;span style="color:#ae81ff">5&lt;/span>, &lt;span style="color:#ae81ff">10&lt;/span>, &lt;span style="color:#ae81ff">17&lt;/span>, &lt;span style="color:#ae81ff">5&lt;/span>, &lt;span style="color:#ae81ff">2&lt;/span>, &lt;span style="color:#ae81ff">17&lt;/span>, &lt;span style="color:#ae81ff">15&lt;/span>, &lt;span style="color:#ae81ff">15&lt;/span>, &lt;span style="color:#ae81ff">17&lt;/span>, &lt;span style="color:#ae81ff">8&lt;/span>, &lt;span style="color:#ae81ff">15&lt;/span>, &lt;span style="color:#ae81ff">14&lt;/span>, &lt;span style="color:#ae81ff">8&lt;/span>, &lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">11&lt;/span>, &lt;span style="color:#ae81ff">17&lt;/span>]
&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">array_less_than_15&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">array&lt;/span>.&lt;span style="color:#a6e22e">filter&lt;/span>((&lt;span style="color:#a6e22e">element&lt;/span>)=&amp;gt; &lt;span style="color:#a6e22e">element&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">15&lt;/span>)
&lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#a6e22e">array_less_than_15&lt;/span>)
&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">array&lt;/span> &lt;span style="color:#f92672">=&lt;/span> [&lt;span style="color:#ae81ff">5&lt;/span>, &lt;span style="color:#ae81ff">19&lt;/span>, &lt;span style="color:#ae81ff">16&lt;/span>, &lt;span style="color:#ae81ff">7&lt;/span>, &lt;span style="color:#ae81ff">5&lt;/span>, &lt;span style="color:#ae81ff">10&lt;/span>, &lt;span style="color:#ae81ff">17&lt;/span>, &lt;span style="color:#ae81ff">5&lt;/span>, &lt;span style="color:#ae81ff">2&lt;/span>, &lt;span style="color:#ae81ff">17&lt;/span>, &lt;span style="color:#ae81ff">15&lt;/span>, &lt;span style="color:#ae81ff">15&lt;/span>, &lt;span style="color:#ae81ff">17&lt;/span>, &lt;span style="color:#ae81ff">8&lt;/span>, &lt;span style="color:#ae81ff">15&lt;/span>, &lt;span style="color:#ae81ff">14&lt;/span>, &lt;span style="color:#ae81ff">8&lt;/span>, &lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">11&lt;/span>, &lt;span style="color:#ae81ff">17&lt;/span>]
&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">array_less_than_15&lt;/span> &lt;span style="color:#f92672">=&lt;/span> []
&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">i&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;&lt;span style="color:#a6e22e">i&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span> &lt;span style="color:#a6e22e">array&lt;/span>.&lt;span style="color:#a6e22e">length&lt;/span> ; &lt;span style="color:#a6e22e">i&lt;/span>&lt;span style="color:#f92672">++&lt;/span>){
&lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#a6e22e">array&lt;/span>[&lt;span style="color:#a6e22e">i&lt;/span>]&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#ae81ff">15&lt;/span>){
&lt;span style="color:#a6e22e">array_less_than_15&lt;/span>.&lt;span style="color:#a6e22e">push&lt;/span>(&lt;span style="color:#a6e22e">array&lt;/span>[&lt;span style="color:#a6e22e">i&lt;/span>])
}
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Một điều lưu ý ở đây là chúng ta vẫn sử dụng method built-in của &lt;code>Array&lt;/code> (filter) (vẫn có dính dáng tới OOP, vì Javascript hỗ trợ cả 2 paradigm này). Ngoại trừ &lt;strong>Functional Programming&lt;/strong> thì chúng ta còn có OOP, nói về sự phổ biến của OOP thì không cần phải bàn cãi, vì hiện tại đây là một tượng đài không thể được vượt qua tại thời điểm hiện tại. Giống như &lt;strong>Functional Programming&lt;/strong> luôn luôn xoay quanh function thì OOP lại đặt &lt;code>class&lt;/code> &amp;amp; &lt;code>object&lt;/code> là &lt;em>first-class citizen&lt;/em> và mọi khái niệm xung quanh. Ưu thế của OOP nằm ở việc mô hình hoá mọi khái niệm ở trong chương trình trở thành những thứ quen thuộc, xung quanh đời sống khiến mọi chuyện trở nên dễ dàng tiếp cận với những người mới. Điểm khác biệt lớn nhất so với &lt;strong>Functional Programming&lt;/strong> có lẽ là state - trạng thái - cũng có thể hiểu là dữ liệu. &lt;strong>Functional Programming&lt;/strong> dành phần lớn thời gian để giúp chúng ta mapping - ánh xạ - từ input thành ouput thông qua các function. OOP thì lại quan tâm tới state và cách thay đổi state một cách internally (nội bộ). Có 4 đặc tính cơ bản mà OOP cung cấp cho chúng ta đó là : &lt;strong>Abstraction&lt;/strong>, &lt;strong>Encapsulation&lt;/strong>, &lt;strong>Inheritance&lt;/strong>, and &lt;strong>Polymorphism&lt;/strong>. Ngoại trừ 4 &lt;em>principles&lt;/em> (nguyên lý) cơ bản này ra thì còn có nhiều &lt;strong>Design Pattern&lt;/strong>. &lt;strong>SOLID guidelines&lt;/strong> là một bộ gồm 5 nguyên tắc cơ bản để thiết kế một chương trình dựa trên OOP. Không dám bàn sâu về vì còn non và xanh. Hãy cùng xem xét ví dụ để hiểu rõ hơn (ít nhất là tổng quan). Điều thú vị của Javascript là có thể cài đặt thêm prototype/method rất nhanh dựa trên &lt;strong>Prototype-based implementation&lt;/strong>.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">array&lt;/span> &lt;span style="color:#f92672">=&lt;/span> [&lt;span style="color:#ae81ff">5&lt;/span>, &lt;span style="color:#ae81ff">19&lt;/span>, &lt;span style="color:#ae81ff">16&lt;/span>, &lt;span style="color:#ae81ff">7&lt;/span>, &lt;span style="color:#ae81ff">5&lt;/span>, &lt;span style="color:#ae81ff">10&lt;/span>, &lt;span style="color:#ae81ff">17&lt;/span>, &lt;span style="color:#ae81ff">5&lt;/span>, &lt;span style="color:#ae81ff">2&lt;/span>, &lt;span style="color:#ae81ff">17&lt;/span>, &lt;span style="color:#ae81ff">15&lt;/span>, &lt;span style="color:#ae81ff">15&lt;/span>, &lt;span style="color:#ae81ff">17&lt;/span>, &lt;span style="color:#ae81ff">8&lt;/span>, &lt;span style="color:#ae81ff">15&lt;/span>, &lt;span style="color:#ae81ff">14&lt;/span>, &lt;span style="color:#ae81ff">8&lt;/span>, &lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">11&lt;/span>, &lt;span style="color:#ae81ff">17&lt;/span>]
&lt;span style="color:#75715e">// thay bằng arrow function sẽ không chạy nhé
&lt;/span>&lt;span style="color:#75715e">&lt;/span>Array.&lt;span style="color:#a6e22e">prototype&lt;/span>.&lt;span style="color:#a6e22e">less_than&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">function&lt;/span>(&lt;span style="color:#a6e22e">number&lt;/span>){
&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">array&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> Array();
&lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">!&lt;/span>&lt;span style="color:#a6e22e">number&lt;/span>){
&lt;span style="color:#66d9ef">throw&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> Error(&lt;span style="color:#e6db74">`Expected a number, but got &lt;/span>&lt;span style="color:#e6db74">${&lt;/span>&lt;span style="color:#66d9ef">typeof&lt;/span> &lt;span style="color:#a6e22e">number&lt;/span>&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">`&lt;/span>)
}
&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">element&lt;/span> &lt;span style="color:#66d9ef">of&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>){
&lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#a6e22e">element&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#a6e22e">number&lt;/span>){
&lt;span style="color:#a6e22e">array&lt;/span>.&lt;span style="color:#a6e22e">push&lt;/span>(&lt;span style="color:#a6e22e">element&lt;/span>)
}
}
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">array&lt;/span>
}
&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">array_less_than_15&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">array&lt;/span>.&lt;span style="color:#a6e22e">less_than&lt;/span>(&lt;span style="color:#ae81ff">15&lt;/span>)
&lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#a6e22e">array_less_than_15&lt;/span>)
&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="imperative--declarative-programming">Imperative / Declarative Programming&lt;/h1>
&lt;p>&lt;strong>Imperative&lt;/strong> là phong cách lập trình mà chúng ta phải khai báo từng bước thực hiện và tính toán ở mỗi dòng code, mỗi bước cực kỳ quan trọng vì nó nó thể ảnh hưởng tới kết quả. Đơn giản hơn, chúng ta phải cung cấp &lt;strong>công thức&lt;/strong> giúp biến đổi &lt;em>input&lt;/em> thành &lt;em>output&lt;/em>.&lt;/p>
&lt;p>&lt;strong>Declarative&lt;/strong> thì ít rắc rối hơn, chúng ta chỉ cần khai báo input và sử dụng các công thức có sẵn một cách phù hợp để tạo ra output, chúng ta có thể thêm một vài tuỳ chọn vào, nhưng hầu hết đều không ảnh hưởng tới công thức. Bằng cách này, chúng ta tiết kiệm rất nhiều thời gian và công sức khi viết code, không cần phải mất thời gian chỉ rõ rằng phải làm gì ở bước này, bước kia, lặp như nào, điều kiện ra sao,et cetera.&lt;/p>
&lt;p>Điều khác biệt ở 2 programming style này nằm ở thứ tự. Bạn là một người pha chế rất giỏi, biết rất nhiều công thức pha cà phê ngon, và bây giờ bạn đang chỉ cho cái máy làm từng bước để đạt được kết quả như bạn. Kiến thức cốt lõi ở đây là &lt;strong>công thức&lt;/strong> - cách giải quyết vấn đề - khi nói về &lt;strong>Imperative&lt;/strong>, điều quan trọng nhất là &lt;strong>HOW&lt;/strong>. Còn đối với &lt;strong>Declarative&lt;/strong> thì &lt;strong>WHAT&lt;/strong> hoặc là &lt;strong>WHICH&lt;/strong> mới là thứ quan trọng. Giả sử chúng ta có một cái máy pha coffee có thể pha mọi loại coffee trên đời với nhiều công thức có sẵn. Vậy thứ chúng ta cung cấp chỉ đơn giản là hạt coffee và chọn thứ coffee chúng ta muốn. Điều quan trọng ở đây, là chúng ta cần phải biết được các công thức có sẵn &lt;strong>làm việc gì&lt;/strong> và vận dụng nó ra sao.&lt;/p>
&lt;p>Điển hình về sự khác nhau thì ta có thể xem lại 2 ví dụ trên.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">array&lt;/span> &lt;span style="color:#f92672">=&lt;/span> [&lt;span style="color:#ae81ff">5&lt;/span>, &lt;span style="color:#ae81ff">19&lt;/span>, &lt;span style="color:#ae81ff">16&lt;/span>, &lt;span style="color:#ae81ff">7&lt;/span>, &lt;span style="color:#ae81ff">5&lt;/span>, &lt;span style="color:#ae81ff">10&lt;/span>, &lt;span style="color:#ae81ff">17&lt;/span>, &lt;span style="color:#ae81ff">5&lt;/span>, &lt;span style="color:#ae81ff">2&lt;/span>, &lt;span style="color:#ae81ff">17&lt;/span>, &lt;span style="color:#ae81ff">15&lt;/span>, &lt;span style="color:#ae81ff">15&lt;/span>, &lt;span style="color:#ae81ff">17&lt;/span>, &lt;span style="color:#ae81ff">8&lt;/span>, &lt;span style="color:#ae81ff">15&lt;/span>, &lt;span style="color:#ae81ff">14&lt;/span>, &lt;span style="color:#ae81ff">8&lt;/span>, &lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">11&lt;/span>, &lt;span style="color:#ae81ff">17&lt;/span>]
&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">array_less_than_15&lt;/span> &lt;span style="color:#f92672">=&lt;/span> []
&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">i&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;&lt;span style="color:#a6e22e">i&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span> &lt;span style="color:#a6e22e">array&lt;/span>.&lt;span style="color:#a6e22e">length&lt;/span> ; &lt;span style="color:#a6e22e">i&lt;/span>&lt;span style="color:#f92672">++&lt;/span>){
&lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#a6e22e">array&lt;/span>[&lt;span style="color:#a6e22e">i&lt;/span>]&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#ae81ff">15&lt;/span>){
&lt;span style="color:#a6e22e">array_less_than_15&lt;/span>.&lt;span style="color:#a6e22e">push&lt;/span>(&lt;span style="color:#a6e22e">array&lt;/span>[&lt;span style="color:#a6e22e">i&lt;/span>])
}
}
&lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#a6e22e">array_less_than_15&lt;/span>)
&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">array&lt;/span> &lt;span style="color:#f92672">=&lt;/span> [&lt;span style="color:#ae81ff">5&lt;/span>, &lt;span style="color:#ae81ff">19&lt;/span>, &lt;span style="color:#ae81ff">16&lt;/span>, &lt;span style="color:#ae81ff">7&lt;/span>, &lt;span style="color:#ae81ff">5&lt;/span>, &lt;span style="color:#ae81ff">10&lt;/span>, &lt;span style="color:#ae81ff">17&lt;/span>, &lt;span style="color:#ae81ff">5&lt;/span>, &lt;span style="color:#ae81ff">2&lt;/span>, &lt;span style="color:#ae81ff">17&lt;/span>, &lt;span style="color:#ae81ff">15&lt;/span>, &lt;span style="color:#ae81ff">15&lt;/span>, &lt;span style="color:#ae81ff">17&lt;/span>, &lt;span style="color:#ae81ff">8&lt;/span>, &lt;span style="color:#ae81ff">15&lt;/span>, &lt;span style="color:#ae81ff">14&lt;/span>, &lt;span style="color:#ae81ff">8&lt;/span>, &lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">11&lt;/span>, &lt;span style="color:#ae81ff">17&lt;/span>]
&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">array_less_than_15&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">array&lt;/span>.&lt;span style="color:#a6e22e">filter&lt;/span>((&lt;span style="color:#a6e22e">element&lt;/span>)=&amp;gt; &lt;span style="color:#a6e22e">element&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">15&lt;/span>)
&lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#a6e22e">array_less_than_15&lt;/span>)
&lt;/code>&lt;/pre>&lt;/div>&lt;hr>
&lt;h1 id="references--more-resources">References &amp;amp; more resources&lt;/h1>
&lt;ul>
&lt;li>&lt;a class="link" href="https://qz.com/852770/theres-a-limit-to-how-small-we-can-make-transistors-but-the-solution-is-photonic-chips/" target="_blank" rel="noopener"
>https://qz.com/852770/theres-a-limit-to-how-small-we-can-make-transistors-but-the-solution-is-photonic-chips/&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://en.wikipedia.org/wiki/Computer" target="_blank" rel="noopener"
>https://en.wikipedia.org/wiki/Computer&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://www.cs.uaf.edu/courses/cs301/2014-fall/notes/goto/" target="_blank" rel="noopener"
>https://www.cs.uaf.edu/courses/cs301/2014-fall/notes/goto/&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://en.wikipedia.org/wiki/Procedural_programming" target="_blank" rel="noopener"
>https://en.wikipedia.org/wiki/Procedural_programming&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://www.educative.io/edpresso/pass-by-value-vs-pass-by-reference" target="_blank" rel="noopener"
>https://www.educative.io/edpresso/pass-by-value-vs-pass-by-reference&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://stackoverflow.com/questions/373419/whats-the-difference-between-passing-by-reference-vs-passing-by-value" target="_blank" rel="noopener"
>https://stackoverflow.com/questions/373419/whats-the-difference-between-passing-by-reference-vs-passing-by-value&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://en.wikipedia.org/wiki/Functional_programming" target="_blank" rel="noopener"
>https://en.wikipedia.org/wiki/Functional_programming&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://en.wikipedia.org/wiki/Object-oriented_programming" target="_blank" rel="noopener"
>https://en.wikipedia.org/wiki/Object-oriented_programming&lt;/a>&lt;/li>
&lt;/ul>
&lt;h3 id="ps">P/S:&lt;/h3>
&lt;p>Nếu có gì sai sót xin gửi email cho mình để cập nhật, xin cảm ơn!&lt;/p></description></item><item><title>Event Loops</title><link>https://sonlhcsuit.github.io/p/event-loops/</link><pubDate>Fri, 23 Apr 2021 09:02:11 +0700</pubDate><guid>https://sonlhcsuit.github.io/p/event-loops/</guid><description>&lt;img src="https://sonlhcsuit.github.io/p/event-loops/cover.png" alt="Featured image of post Event Loops" />&lt;p>Javascript là một ngôn ngữ lập trình duy nhất ở thời điểm hiện tại có thể chạy trên trình duyệt web ( WA - Web assembly có thể chạy trên browser, web assembly khiến cho binary code có thể chạy trên nền web). Duy nhất ở đây không phải là không thể tạo ra ngôn ngữ nào khác thay thế mà là không cần thiết vì Javascript đã quá trở nên phổ biến (ở đây tập trung nói về client-side Javascript). Javascript được thiết kế theo &lt;strong>event-driven&lt;/strong> paradigm (Hướng sự kiện). Javascript không phải là ngôn ngữ duy nhất được thiết kế dựa trên paradigm này (Hầu hết các ngôn ngữ hỗ trợ xây dựng GUI đều hỗ trợ).&lt;/p>
&lt;h1 id="event-driven-paradigm">Event-driven Paradigm&lt;/h1>
&lt;p>Giống như OOP được thiết kế dựa trên các &lt;code>Object&lt;/code> &amp;amp; &lt;code>Class&lt;/code> thì event-driven programming language được thiết kế dựa trên thành phần chủ yếu là &lt;code>Event&lt;/code> &amp;amp; &lt;code>Listener&lt;/code>. Đa phần các ngôn ngữ lập trình có thể xây dựng ứng dụng (application) đều hỗ trợ paradigm (Java, C, C++, et cetera). Lưu ý rằng là application ở đây không chỉ nói riêng về các GUI ở phía client mà còn cả ở phía server, vì server cũng phải luôn lắng nghe các request từ internet (dễ dàng mở rộng, tích hợp). Các ngôn ngữ lập trình đã hỗ trợ các &lt;strong>event&lt;/strong> built-in (click, nhập liệu, di chuyển chuột, đọc file, xoá file, et cetera).&lt;/p>
&lt;h1 id="event-emitters--event-listeners">Event Emitters / Event Listeners&lt;/h1>
&lt;p>Event có rất nhiều loại, tuy nhiên ta có thể khái quát lại thế giới của event-driven paradigm gồm : &lt;code>emitters&lt;/code> &amp;amp; &lt;code>listeners&lt;/code>. Một &lt;strong>event&lt;/strong> được định nghĩa là một hành động nào đó xảy ra, khi các điều kiện phù hợp với một tiêu chuẩn nào đó , &lt;strong>event&lt;/strong> đó sẽ &lt;code>emit&lt;/code> ra một tín hiệu (&lt;code>signal&lt;/code>) đến cho nhiều &lt;code>listener&lt;/code> đang chờ đợi tín hiệu đó. Khi nhận được các tín hiệu thì các &lt;code>listener&lt;/code> sẽ được thực thi. Thông thường &lt;code>listener&lt;/code> là các hàm (callback) đã được khai báo sẵn, khi nhận được tín hiệu thì sẽ lập tức thực thi. Điều này cho phép ta sắp đặt các &lt;code>listener&lt;/code> phù hợp với tương ứng với các event. Ví dụ như khi người dùng click nút &lt;code>Mua&lt;/code> thì ta sẽ lập tức hiển thị lên thông tin về giao dịch, &amp;hellip;&lt;/p>
&lt;p>Ta cũng có nhiều vấn đề phát sinh như sau:&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Event&lt;/strong> &lt;code>emit&lt;/code> tín hiệu khi chương trình kết thúc thì như thế nào?&lt;/li>
&lt;li>Làm sao chúng ta biết được khi nào một &lt;strong>Event&lt;/strong> &lt;code>emit&lt;/code> tín hiệu?&lt;/li>
&lt;li>Lúc nhận được tín hiệu mà chúng ta đang thực hiện đoạn code khác thì sao?&lt;/li>
&lt;li>&amp;hellip;&lt;/li>
&lt;/ul>
&lt;p>Thông thường đối với vấn đề thứ nhất và thứ hai, ta sẽ chọn cách giải quyết là để chương trình luôn chạy, luôn luôn khiến các &lt;code>listener&lt;/code> ỏ trong trạng thái sẵn sàng (mặc dù đã hết phần code ở phần main) tín hiệu từ Event. Vấn đề thứ ba ta có thể sử dụng đa luồng để giải quyết.&lt;/p>
&lt;p>Lợi ích của event-driven paradigm gồm đơn giản và dễ mở rộng. Ví dụ về vấn đề mua hàng, ta có thể mở rộng bằng cách thêm các listener đảm nhận chức năng sign up/sign in vào mà không ảnh hưởng code của việc thực hiện giao dịch (tất nhiên vẫn phải đảm bảo logic: đã đăng nhập =&amp;gt; điền thông tin =&amp;gt; hiển thị thông tin giao dịch), giúp chúng ta tracing (theo dấu) được các hành vi của người dùng một cách tốt hơn.&lt;/p>
&lt;h1 id="event-loops">Event Loops&lt;/h1>
&lt;p>Tổng kết lại, một hành động &lt;code>listener&lt;/code> sẽ được thực thi khi một sự kiện &lt;code>event&lt;/code> nào đó được xảy ra (không nhất thiết từ phía người dùng). Để các &lt;code>event&lt;/code> &amp;amp; &lt;code>listener&lt;/code> chạy đúng đắn (&lt;code>event&lt;/code> này xảy ra thì &lt;code>listener&lt;/code> này được thực hiện, et cetera) thì chương trình cần phải chạy liên tục, luôn luôn chờ &lt;code>signal&lt;/code> từ các &lt;code>event emitter&lt;/code> (nguồn phát tín hiệu báo sự kiện hoàn thành ) để có thể thực hiện các &lt;code>listener&lt;/code>. &lt;strong>Event Loops&lt;/strong> là cơ chế giúp javascript có thể luôn chờ các tín hiệu phát ra, và điều phối thứ tự thực hiện các &lt;code>listener&lt;/code> của nhiều &lt;code>event&lt;/code> khác nhau. Event Loops giống một đứa con nít luôn hỏi mẹ &amp;ldquo;Mẹ ơi khi nào về?&amp;rdquo;, chỉ khác thứ &lt;strong>Event Loops&lt;/strong> yêu cầu là tín hiệu của bất kỳ &lt;code>event&lt;/code>. Javascript khi nhận được &lt;code>signal&lt;/code> từ &lt;code>event emitter&lt;/code> sẽ tìm kiếm đến các &lt;code>listener&lt;/code> (một hàm callback) đang lắng nghe &lt;code>event&lt;/code> và thực hiện (execute, call, invoke) nó.&lt;/p>
&lt;p>&lt;figure style="flex-grow: 106; flex-basis: 255px">
&lt;a href="https://sonlhcsuit.github.io/p/event-loops/img-1.png" data-size="734x689">&lt;img src="https://sonlhcsuit.github.io/p/event-loops/img-1.png"
srcset="https://sonlhcsuit.github.io/p/event-loops/img-1_hu38b9218ffc448345a22f3f9616787b81_25269_480x0_resize_box_3.png 480w, https://sonlhcsuit.github.io/p/event-loops/img-1_hu38b9218ffc448345a22f3f9616787b81_25269_1024x0_resize_box_3.png 1024w"
width="734"
height="689"
loading="lazy"
alt="Event loops - client side">
&lt;/a>
&lt;figcaption>Event loops - client side&lt;/figcaption>
&lt;/figure>
&lt;figure style="flex-grow: 241; flex-basis: 579px">
&lt;a href="https://sonlhcsuit.github.io/p/event-loops/img-2.png" data-size="1120x464">&lt;img src="https://sonlhcsuit.github.io/p/event-loops/img-2.png"
srcset="https://sonlhcsuit.github.io/p/event-loops/img-2_hu819fc556566a62b34a283c94f16a21d0_18977_480x0_resize_box_3.png 480w, https://sonlhcsuit.github.io/p/event-loops/img-2_hu819fc556566a62b34a283c94f16a21d0_18977_1024x0_resize_box_3.png 1024w"
width="1120"
height="464"
loading="lazy"
alt="Event loops - nodejs">
&lt;/a>
&lt;figcaption>Event loops - nodejs&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>Điều đáng chú ý rằng javascript là một ngôn ngữ &lt;strong>single thread&lt;/strong> (đơn luồng) dẫn tới việc javascript chỉ có 1 heap và 1 callstack (callback có thể sử dụng nhiều hàm chức năng khác nên callstack là cần thiết). Nếu nhiều &lt;code>event&lt;/code> phát ra tín hiệu liên tiếp thì có cách giải quyết nào? Để giải quyết trường hợp này thì javascript hỗ trợ thêm khái niệm &lt;strong>Event Queue&lt;/strong>, nhằm mục đích lưu trữ thứ tự các signal được emit từ các event khác nhau. Khi một &lt;code>listener&lt;/code> được hoàn thành (thường là callstack trống), &lt;strong>Event Queue&lt;/strong> sẽ lần lượt xử lý các &lt;code>listener&lt;/code> tiếp theo.&lt;/p>
&lt;p>Javascript lúc bình thường sẽ chạy từng dòng một từ trên xuống đồng bộ (synchronous), tuy nhiên khi các &lt;code>event&lt;/code> phát ra &lt;code>signal&lt;/code> thì phải được xử lý thông qua &lt;strong>Event Queue&lt;/strong> (Từng event một sẽ được xử lý).&lt;/p>
&lt;h1 id="webapis-and-synchronous---asynchronous">WebAPIs and Synchronous - Asynchronous&lt;/h1>
&lt;p>Synchronous nghĩa là đồng bộ, nhằm chỉ việc code của chúng ta sẽ được thực thi theo thứ tự nhất định (từng dòng 1). Khi gặp các tao thác I/O thì code sẽ bị block (không chạy phần phía dưới) cho đến khi I/O hoàn thành (điển hình là &lt;code>alert&lt;/code> &amp;amp; &lt;code>prompt&lt;/code>). Cơ chế event queue của javascript cũng được tính vào synchronous và asynchronous.&lt;/p>
&lt;p>Xem xét ví dụ sau đây.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-js" data-lang="js">&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">btn&lt;/span> &lt;span style="color:#f92672">=&lt;/span> document.&lt;span style="color:#a6e22e">querySelector&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;#btn&amp;#34;&lt;/span>)
&lt;span style="color:#a6e22e">btn&lt;/span>.&lt;span style="color:#a6e22e">addEventListener&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;click&amp;#34;&lt;/span>,()=&amp;gt;{
&lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;clicked&amp;#34;&lt;/span>)
})
&lt;span style="color:#a6e22e">btn&lt;/span>.&lt;span style="color:#a6e22e">click&lt;/span>() &lt;span style="color:#75715e">// thực hiện thao tác click vào nút, thay vì đợi người dùng click
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;he?&amp;#34;&lt;/span>)
&lt;span style="color:#75715e">// clicked
&lt;/span>&lt;span style="color:#75715e">// he
&lt;/span>&lt;span style="color:#75715e">// listener được execute trước!
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Asynchronous nghĩa là bất đồng bộ, hằm chỉ việc code của chúng ta sẽ không được thực thi theo thứ tự đã viết.
Xem xét ví dụ sau đây.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">btn&lt;/span> &lt;span style="color:#f92672">=&lt;/span> document.&lt;span style="color:#a6e22e">querySelector&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;#btn&amp;#34;&lt;/span>)
&lt;span style="color:#a6e22e">btn&lt;/span>.&lt;span style="color:#a6e22e">addEventListener&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;click&amp;#34;&lt;/span>,()=&amp;gt;{
&lt;span style="color:#a6e22e">setTimeout&lt;/span>(()=&amp;gt;{
&lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;clicked&amp;#34;&lt;/span>)
},&lt;span style="color:#ae81ff">0&lt;/span>)
})
&lt;span style="color:#a6e22e">btn&lt;/span>.&lt;span style="color:#a6e22e">addEventListener&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;click&amp;#34;&lt;/span>,()=&amp;gt;{
&lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;clicked 2&amp;#34;&lt;/span>)
})
&lt;span style="color:#a6e22e">btn&lt;/span>.&lt;span style="color:#a6e22e">click&lt;/span>() &lt;span style="color:#75715e">// thực hiện thao tác click vào nút, thay vì đợi người dùng click
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;he?&amp;#34;&lt;/span>)
&lt;span style="color:#75715e">// clicked 2
&lt;/span>&lt;span style="color:#75715e">// he
&lt;/span>&lt;span style="color:#75715e">// clicked
&lt;/span>&lt;span style="color:#75715e">// listener được execute sau!
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Lí giải tại sao ví dụ thứ 2 lại có kết quả như vậy là bởi vì có sự can thiệp của &lt;code>Web API&lt;/code>. WebAPI hỗ trợ chúng ta nhiều thứ như &lt;code>ajax&lt;/code>, &lt;code>timers&lt;/code>, &lt;code>file reader&lt;/code>, et cetera. Về mặt bản chất thì Web API cũng hoạt động dựa trên event queue, tuy nhiên hơi khác một tí là: Nếu sử dụng Web APIs thì thứ tự ưu tiên của event được emit từ Web APIs sẽ &amp;ldquo;kém hơn&amp;rdquo; các event, nghĩa là Event sẽ bị hoãn cho tới khi callstack trống (code của chương trình chính được chạy hoàn toàn) thì mới được đưa vào Event Queue và bắt đầu xử lý theo quy tắc của Event Queue( lấy từng Event ra -&amp;gt; tạo callstack mới -&amp;gt; execute listener).&lt;/p>
&lt;p>Hãy thử đoạn code trên với vòng lặp for dùng để blocking khoảng 2s&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">btn&lt;/span> &lt;span style="color:#f92672">=&lt;/span> document.&lt;span style="color:#a6e22e">querySelector&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;#btn&amp;#34;&lt;/span>)
&lt;span style="color:#a6e22e">btn&lt;/span>.&lt;span style="color:#a6e22e">addEventListener&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;click&amp;#34;&lt;/span>,()=&amp;gt;{
&lt;span style="color:#a6e22e">setTimeout&lt;/span>(()=&amp;gt;{
&lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;clicked&amp;#34;&lt;/span>)
},&lt;span style="color:#ae81ff">0&lt;/span>)
})
&lt;span style="color:#a6e22e">btn&lt;/span>.&lt;span style="color:#a6e22e">addEventListener&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;click&amp;#34;&lt;/span>,()=&amp;gt;{
&lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;clicked 2&amp;#34;&lt;/span>)
})
&lt;span style="color:#a6e22e">btn&lt;/span>.&lt;span style="color:#a6e22e">click&lt;/span>() &lt;span style="color:#75715e">// thực hiện thao tác click vào nút, thay vì đợi người dùng click
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">i&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;&lt;span style="color:#a6e22e">i&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#ae81ff">3000000000&lt;/span>;&lt;span style="color:#a6e22e">i&lt;/span>&lt;span style="color:#f92672">++&lt;/span>){
&lt;span style="color:#75715e">// block 3s
&lt;/span>&lt;span style="color:#75715e">&lt;/span>}
&lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;he?&amp;#34;&lt;/span>)
&lt;span style="color:#75715e">// clicked 2
&lt;/span>&lt;span style="color:#75715e">// Phải đợi khoảng 3s, mặc dù hàm setTimeout có thời gian đợi là 0s!
&lt;/span>&lt;span style="color:#75715e">// he
&lt;/span>&lt;span style="color:#75715e">// clicked
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Những tác vụ có sử dụng Web APIs được gọi là những tác vụ asynchronous (điều ngược lại không đúng). Các tác vụ asynchronous (thường là &lt;code>function&lt;/code>) sẽ có độ ưu tiên kém (chỉ được thêm vào event queue khi &lt;code>callstack&lt;/code> trống lần đầu tiên - Hoàn thành hết code synchronous). Sau đó thì cũng sẽ được xử lý dưới cơ chế &lt;strong>event queue&lt;/strong> &amp;amp; &lt;strong>event loops&lt;/strong>. Sau khi đã qua hoàn thành code javascript synchronous thì mọi thứ sẽ được nhường về cho &lt;strong>Event Loops&lt;/strong> và những thứ liên quan. Nên chú ý một chút về các &lt;code>listener&lt;/code>, các &lt;code>listener&lt;/code> phải được hoàn thành toàn bộ (callstack rỗng) thì event queue mới có thể đưa &lt;code>listener&lt;/code> kế tiếp vào hoàn thành, vậy nên nếu &lt;code>listener&lt;/code> trước chưa được hoàn thành thì phải đợi chờ đến khi được hoàn thành. Khi một listener đang chạy (tốn thời gian rất lâu) thì các interaction khác sẽ không chạy (ví dụ như &lt;code>scroll&lt;/code>, &lt;code>click&lt;/code>,..) cho nên đừng có làm gì quá rắc rối trong &lt;code>listener&lt;/code> - Ví dụ như animation, đệ quy không có điểm dừng, tính số fibnacci ,&amp;hellip; - cơ chế này có tên là &amp;ldquo;Run to completion&amp;rdquo;.&lt;/p>
&lt;p>Đây cũng chính là sức mạnh của Javascript khi so sánh với các ngôn ngữ khác!&lt;/p>
&lt;p>Tổng kết lại, &lt;strong>event loops&lt;/strong> sẽ xem xét xem thử có bất kỳ &lt;code>event&lt;/code> nào phát ra tín hiệu không? Nếu có thì sẽ thêm vào event queue. Nếu callstack trống, &lt;strong>event queue&lt;/strong> sẽ xử lý từng &lt;code>listener&lt;/code> tương ứng với signal được &lt;code>event&lt;/code> phát ra. &lt;strong>WebAPIs&lt;/strong> cung cấp cho chúng ta các công cụ tiện lợi(&lt;code>timers&lt;/code>, &lt;code>fetch&lt;/code>, &lt;code>file reader&lt;/code>, et cetera) và hoạt động dựa vào &lt;strong>event loops&lt;/strong>! Tuy nhiên WebAPIs bao gồm nhiều hành động asynchronous, kỹ năng xử lý hành động asynchronous rất quan trọng khi làm việc với Javascript.&lt;/p>
&lt;p>Có một câu hỏi hay khi phỏng vấn như thế này:&amp;ldquo;Javascript là ngôn ngữ lập trình đơn luồng hay là đa luồng? Tại sao Javascript lại là đơn luồng/ đa luồng? Nếu Javascript là đơn luồng thì tại sao tại thực hiện được nhiều tác vụ cùng một lúc (ví dụ như fetch nhiều request cùng lúc)?&amp;rdquo;. Điều đâu tiên, javascript là ngôn ngữ đơn luồng bởi vì javascript chỉ có duy nhất một &lt;strong>callstack&lt;/strong> và &lt;strong>heap&lt;/strong>. Javascript không thực sự xử lý nhiều &lt;code>request&lt;/code> cùng 1 lúc, chỉ là cơ chế Event loops của Javascript khiến cho Javascript trông như có thể xử lý nhiều hành động cùng 1 lúc (nhiều &lt;code>event&lt;/code> có thể xảy ra cùng 1 lúc nhưng các &lt;code>listeners&lt;/code> thì phải được giải quyết theo thứ tự). Nói về hàm &lt;code>fetch&lt;/code>, Javascript có thể sử dụng hàm &lt;code>fetch&lt;/code> để lấy thông tin nhiều &lt;code>request&lt;/code> cùng lúc (&lt;code>Promise.all&lt;/code>), tuy nhiên, fetch là &lt;strong>WebAPIs&lt;/strong> - nghĩa là thứ thực hiện việc gọi nhiều request cùng lúc là Browser, runtime engine chứ không phải Javascript. Khi tất cả các request được hoàn thành (nhận được response) thì &lt;strong>WebAPIs&lt;/strong> sẽ đẩy Event vào &lt;strong>Event Queue&lt;/strong>, lúc này các &lt;code>listeners&lt;/code> (hay là các đoạn code handle &lt;code>promise&lt;/code>) sẽ được thực hiện lần lượt.&lt;/p>
&lt;hr>
&lt;h1 id="references--more-resources">References &amp;amp; more resources&lt;/h1>
&lt;ul>
&lt;li>&lt;a class="link" href="https://en.wikipedia.org/wiki/Event-driven_programming" target="_blank" rel="noopener"
>https://en.wikipedia.org/wiki/Event-driven_programming&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop" target="_blank" rel="noopener"
>https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://www.youtube.com/watch?v=8aGhZQkoFbQ" target="_blank" rel="noopener"
>https://www.youtube.com/watch?v=8aGhZQkoFbQ&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://medium.com/@giangcoffee/event-loop-l%C3%A0-g%C3%AC-v%C3%A0-ho%E1%BA%A1t-%C4%91%E1%BB%99ng-th%E1%BA%BF-n%C3%A0o-d52caa908090" target="_blank" rel="noopener"
>https://medium.com/@giangcoffee/event-loop-l%C3%A0-g%C3%AC-v%C3%A0-ho%E1%BA%A1t-%C4%91%E1%BB%99ng-th%E1%BA%BF-n%C3%A0o-d52caa908090&lt;/a>&lt;/li>
&lt;/ul>
&lt;h3 id="ps">P/S:&lt;/h3>
&lt;p>Các đoạn code ở trên được mình chạy ở trên engine V8 của Chrome thông qua trình duyệt Brave. Có thể tuỳ thuộc vào các engine có một cách thực thi Javascript khác nhau nên có gì sai sót xin email cho mình để mình cập nhật. Xin cảm ơn!&lt;/p></description></item><item><title>Functions</title><link>https://sonlhcsuit.github.io/p/function/</link><pubDate>Sun, 18 Apr 2021 00:17:35 +0700</pubDate><guid>https://sonlhcsuit.github.io/p/function/</guid><description>&lt;img src="https://sonlhcsuit.github.io/p/function/cover.png" alt="Featured image of post Functions" />&lt;h1 id="function">Function&lt;/h1>
&lt;p>&lt;strong>Function&lt;/strong> là một khái niệm quan trọng trong nhiều ngôn ngữ lập trình bậc cao. Theo định nghĩa từ toán học thì &lt;strong>function&lt;/strong> là những &lt;strong>expression, rules,laws&lt;/strong> được sử dụng để định nghĩa những &lt;strong>relation&lt;/strong> giữa nhiều &lt;strong>dependant variables&lt;/strong> (biến độc lập). Nói một cách khó hiểu hơn, là một &lt;strong>mapping&lt;/strong> (ánh xạ) từ một giá trị ở &lt;em>miền giá trị&lt;/em> này sang một giá trị khác ở &lt;em>miền giá trị&lt;/em> khác.&lt;/p>
&lt;p>&lt;figure style="flex-grow: 208; flex-basis: 500px">
&lt;a href="https://sonlhcsuit.github.io/p/function/function-algebra.png" data-size="828x397">&lt;img src="https://sonlhcsuit.github.io/p/function/function-algebra.png"
srcset="https://sonlhcsuit.github.io/p/function/function-algebra_hu311918eba7412b1275f9d8949c4bb2a8_8626_480x0_resize_box_3.png 480w, https://sonlhcsuit.github.io/p/function/function-algebra_hu311918eba7412b1275f9d8949c4bb2a8_8626_1024x0_resize_box_3.png 1024w"
width="828"
height="397"
loading="lazy"
alt="Định nghĩa về function theo toán học">
&lt;/a>
&lt;figcaption>Định nghĩa về function theo toán học&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>Khi làm việc với các ngôn ngữ lập trình thì chúng ta lại sử dụng hàm khác đi một chút. &lt;strong>Function&lt;/strong> là một &amp;ldquo;cỗ máy&amp;rdquo; nhận vào những &lt;strong>input&lt;/strong> và đưa ra cho chúng ta &lt;strong>output&lt;/strong>. Khi viết một hàm, chúng ta đang thiết kế cách mà &amp;ldquo;cỗ máy&amp;rdquo; hoạt động, cách chuyển đổi từ &lt;strong>input&lt;/strong> sang &lt;strong>output&lt;/strong>, chúng ta có thể sử dụng bản thiết kế này chúng ở mọi nơi bằng cách &lt;strong>invoke,call&lt;/strong> (gọi hàm - sẽ có sự khác biệt phía bên dưới).&lt;/p>
&lt;p>&lt;figure style="flex-grow: 82; flex-basis: 199px">
&lt;a href="https://sonlhcsuit.github.io/p/function/function-machine.png" data-size="500x603">&lt;img src="https://sonlhcsuit.github.io/p/function/function-machine.png"
srcset="https://sonlhcsuit.github.io/p/function/function-machine_huc25f250195a519fdfdea4f9a43f2fd11_14605_480x0_resize_box_3.png 480w, https://sonlhcsuit.github.io/p/function/function-machine_huc25f250195a519fdfdea4f9a43f2fd11_14605_1024x0_resize_box_3.png 1024w"
width="500"
height="603"
loading="lazy"
alt="Định nghĩa về function nhưng bớt khó hiểu hơn">
&lt;/a>
&lt;figcaption>Định nghĩa về function nhưng bớt khó hiểu hơn&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;h1 id="create-function">Create function&lt;/h1>
&lt;p>Có một vài điều cần lưu ý khi sử dụng &lt;strong>function&lt;/strong> như sau:
- Phải khai báo &lt;strong>function&lt;/strong> trước khi sử dụng
- &lt;strong>function&lt;/strong> không chạy tại thời điểm được khai báo mà chỉ chạy khi được invoke/call
Ngoại trừ những điều trên thì còn một vài thứ linh tinh nữa. Trong Javascript thì chúng ta có thể khai báo &lt;strong>function&lt;/strong> bằng 2 cách - sử dụng &lt;strong>function definition&lt;/strong> hoặc &lt;strong>function expression&lt;/strong>. Javascript xem &lt;strong>function&lt;/strong> như là một đối tượng, nên &lt;strong>function&lt;/strong> có thể là &lt;strong>output&lt;/strong> của một function khác.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="color:#75715e">// Sử dụng function definition với từ khoá function
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">functionName&lt;/span>(&lt;span style="color:#a6e22e">parameters_comes_here&lt;/span>){
&lt;span style="color:#75715e">// function_body here
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// remember to return something
&lt;/span>&lt;span style="color:#75715e">&lt;/span>}
&lt;span style="color:#75715e">// Sử dụng function expression
&lt;/span>&lt;span style="color:#75715e">// const / let/ var đều có thể
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">myFunctionName&lt;/span> &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#a6e22e">parameters_comes_here&lt;/span>)=&amp;gt;{
&lt;span style="color:#75715e">// function_body here
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// remember to return something
&lt;/span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="parameter--argument">Parameter / Argument&lt;/h1>
&lt;p>Khi khai báo hàm thì ta cần phải chú ý &lt;strong>function name&lt;/strong> (quy tắc đặt tên giống tên biến) và &lt;strong>function parameter&lt;/strong>. &lt;strong>Parameter&lt;/strong> nghĩa là tham số đầu vào - một cách gọi khác của &lt;strong>input&lt;/strong>. &lt;strong>Parameter&lt;/strong> là biến dùng để lưu giá trị nhận được khi &lt;strong>function&lt;/strong> được invoke/call. &lt;strong>Function&lt;/strong> sẽ yêu cầu một số lượng nhất định các &lt;strong>parameter&lt;/strong> khi khai báo, đồng thời cũng phải đúng số lượng các &lt;strong>argument&lt;/strong> truyền vào khi hàm được &lt;strong>invoke/call&lt;/strong> và đúng thứ tự được khai báo . Tuy nhiên Javascript không bắt buộc điều này, số lượng các &lt;strong>parameter&lt;/strong> và &lt;strong>argument&lt;/strong> có thể khác nhau. Điều này dẫn tới một số vấn nhỏ.&lt;br>
Đối với việc số lượng các &lt;strong>parameter&lt;/strong> và &lt;strong>argument&lt;/strong> bằng nhau.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="color:#75715e">// Khai báo hàm cube với 3 parameter là a, b, c
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">cube&lt;/span>(&lt;span style="color:#a6e22e">a&lt;/span>,&lt;span style="color:#a6e22e">b&lt;/span>,&lt;span style="color:#a6e22e">c&lt;/span>){
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">a&lt;/span>&lt;span style="color:#f92672">**&lt;/span>&lt;span style="color:#ae81ff">3&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#a6e22e">b&lt;/span>&lt;span style="color:#f92672">**&lt;/span>&lt;span style="color:#ae81ff">3&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#a6e22e">c&lt;/span>&lt;span style="color:#f92672">**&lt;/span>&lt;span style="color:#ae81ff">3&lt;/span>
}
&lt;span style="color:#75715e">// Invoke/call hàm cube với 3 argument tương ứng là 2, 3, 4
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">result&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">cube&lt;/span>(&lt;span style="color:#ae81ff">2&lt;/span>,&lt;span style="color:#ae81ff">3&lt;/span>,&lt;span style="color:#ae81ff">4&lt;/span>)
&lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#a6e22e">result&lt;/span>)
&lt;span style="color:#75715e">// 99
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Đối với việc số lượng các &lt;strong>parameter&lt;/strong> và &lt;strong>argument&lt;/strong> không bằng nhau.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="color:#75715e">// Khai báo hàm cube với 3 parameter là a, b, c
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">cube&lt;/span>(&lt;span style="color:#a6e22e">a&lt;/span>,&lt;span style="color:#a6e22e">b&lt;/span>,&lt;span style="color:#a6e22e">c&lt;/span>){
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">a&lt;/span>&lt;span style="color:#f92672">**&lt;/span>&lt;span style="color:#ae81ff">3&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#a6e22e">b&lt;/span>&lt;span style="color:#f92672">**&lt;/span>&lt;span style="color:#ae81ff">3&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#a6e22e">c&lt;/span>&lt;span style="color:#f92672">**&lt;/span>&lt;span style="color:#ae81ff">3&lt;/span>
}
&lt;span style="color:#75715e">// Invoke/call hàm cube với 2 argument tương ứng là 2, 3
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">result&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">cube&lt;/span>(&lt;span style="color:#ae81ff">2&lt;/span>,&lt;span style="color:#ae81ff">3&lt;/span>)
&lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#a6e22e">result&lt;/span>)
&lt;span style="color:#75715e">// NaN
&lt;/span>&lt;span style="color:#75715e">// Lý do bởi vì giá trị của c không được truyền vào =&amp;gt; các biến
&lt;/span>&lt;span style="color:#75715e">// có giá trị mặc định là undefined nếu không có quá trình initialization
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#75715e">// Invoke/call hàm cube với 5 argument tương ứng là 2, 3, 4, 5, 6
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">result&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">cube&lt;/span>(&lt;span style="color:#ae81ff">2&lt;/span>,&lt;span style="color:#ae81ff">3&lt;/span>,&lt;span style="color:#ae81ff">4&lt;/span>,&lt;span style="color:#ae81ff">5&lt;/span>,&lt;span style="color:#ae81ff">6&lt;/span>)
&lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#a6e22e">result&lt;/span>)
&lt;span style="color:#75715e">// 99
&lt;/span>&lt;span style="color:#75715e">// Thiếu mất giá trị 5, 6. Như vậy liệu rằng hàm
&lt;/span>&lt;span style="color:#75715e">// của chúng có đang ở dạng tổng quát (general)?
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Thông qua 2 ví dụ trên về sự khác biệt số lượng &lt;strong>parameter/argument&lt;/strong>, ta có thể có vài rắc rối cần phải giải quyết. Một trong cách giải quyết đơn giản nhất là sử dụng duy nhất 1 &lt;strong>parameter&lt;/strong> với kiểu dữ liệu là &lt;strong>array&lt;/strong>. Ngoại trừ cách đó thì chúng ta còn có thể sử dụng &lt;strong>reserved word&lt;/strong> là &lt;strong>arguments&lt;/strong> - giúp chúng ta biến tất cả các &lt;strong>arguments&lt;/strong> thành đối tượng array-like (gần như mảng nhưng không phải mảng).&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="color:#75715e">// Sử dụng mảng
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">cube&lt;/span>(&lt;span style="color:#a6e22e">arrayOfNumbers&lt;/span>){
&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">n&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">arrayOfNumbers&lt;/span>.&lt;span style="color:#a6e22e">length&lt;/span>;
&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">sum&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">i&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;&lt;span style="color:#a6e22e">i&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span> &lt;span style="color:#a6e22e">n&lt;/span> ; &lt;span style="color:#a6e22e">i&lt;/span>&lt;span style="color:#f92672">++&lt;/span> ){
&lt;span style="color:#a6e22e">sum&lt;/span>&lt;span style="color:#f92672">+=&lt;/span> &lt;span style="color:#a6e22e">arrayOfNumbers&lt;/span>[&lt;span style="color:#a6e22e">i&lt;/span>]
}
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">n&lt;/span>
}
&lt;span style="color:#75715e">// sử dụng hàm
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">result&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">cube&lt;/span>([&lt;span style="color:#ae81ff">2&lt;/span>,&lt;span style="color:#ae81ff">3&lt;/span>,&lt;span style="color:#ae81ff">4&lt;/span>])
&lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#a6e22e">result&lt;/span>)
&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="color:#75715e">// Sử dụng từ khoá arguments. Khi sử dụng từ khoá thì chúng
&lt;/span>&lt;span style="color:#75715e">// ta có thể không khai báo parameter. Nếu khai báo thì cũng
&lt;/span>&lt;span style="color:#75715e">// vẫn có thể sử dụng như một biến
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">cube&lt;/span>(&lt;span style="color:#a6e22e">a&lt;/span>,&lt;span style="color:#a6e22e">b&lt;/span>,&lt;span style="color:#a6e22e">c&lt;/span>){
&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">n&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">arguments&lt;/span>.&lt;span style="color:#a6e22e">length&lt;/span>;
&lt;span style="color:#75715e">// tuy nhiên chúng ta vẫn có thể truy cập tới arguments[0]
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// arguments[1], arguments[2] bằng a, b, c theo thứ tự
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">sum&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">i&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;&lt;span style="color:#a6e22e">i&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span> &lt;span style="color:#a6e22e">n&lt;/span> ; &lt;span style="color:#a6e22e">i&lt;/span>&lt;span style="color:#f92672">++&lt;/span> ){
&lt;span style="color:#a6e22e">sum&lt;/span>&lt;span style="color:#f92672">+=&lt;/span> &lt;span style="color:#a6e22e">arguments&lt;/span>[&lt;span style="color:#a6e22e">i&lt;/span>]
}
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">n&lt;/span>
}
&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">result&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">cube&lt;/span>(&lt;span style="color:#ae81ff">2&lt;/span>,&lt;span style="color:#ae81ff">3&lt;/span>,&lt;span style="color:#ae81ff">4&lt;/span>,&lt;span style="color:#ae81ff">5&lt;/span>,&lt;span style="color:#ae81ff">6&lt;/span>,&lt;span style="color:#ae81ff">7&lt;/span>,&lt;span style="color:#ae81ff">8&lt;/span>,&lt;span style="color:#ae81ff">9&lt;/span>,&lt;span style="color:#ae81ff">10&lt;/span>)
&lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#a6e22e">result&lt;/span>)
&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="lexical-environment--execution-context--execution-stack">Lexical Environment / Execution Context / Execution Stack&lt;/h1>
&lt;p>Khi khai báo &lt;strong>function&lt;/strong> ta sử dụng cú pháp &lt;strong>{}&lt;/strong> để tạo &lt;strong>scope&lt;/strong> dánh cho &lt;strong>function body&lt;/strong>. &lt;strong>Scope&lt;/strong> này còn có tên là &lt;strong>Lexical Environment&lt;/strong> (&lt;strong>Lexical&lt;/strong>).Khi khai báo identifiers thi identifier sẽ bind với lexical/scope đó (mặc định). Khi một hàm call/invoke (scope thường sẽ được gọi) &lt;strong>Lexical&lt;/strong> thường chứa thông tin về về các &lt;strong>identifier&lt;/strong> , đồng thời cũng chứa thông tin về &lt;strong>parent lexical&lt;/strong> khi tìm kiếm &lt;strong>identifier&lt;/strong> không tồn tại trong &lt;strong>lexical&lt;/strong> hiện tại. Khi một hàm được &lt;strong>invoke/call&lt;/strong> thì ngay lập tức Javascrit engine tạo ra một &lt;strong>execution context&lt;/strong> và một &lt;strong>lexical&lt;/strong> cho việc lưu trữ các biến (giả sử nếu cùng tên trong hàm). &lt;strong>Execution context&lt;/strong> đặt chúng lên đầu của &lt;strong>execution stack&lt;/strong>, đồng thời lưu vào &lt;strong>lexical&lt;/strong> vị trí của &lt;strong>statement pointer&lt;/strong> hiện tại, đồng thời cập nhật giá trị &lt;strong>statement pointer&lt;/strong> thành nơi bắt đầu hàm vừa được &lt;strong>invoke/call&lt;/strong>. &lt;strong>Execution context&lt;/strong> lớn nhất là &lt;strong>global&lt;/strong>.&lt;/p>
&lt;p>Javascript engine sẽ thực hiện lần lượt từ trên xuống dưới (top to bottom of stack). Khi &lt;strong>function&lt;/strong> hoàn thành, &lt;strong>execution context&lt;/strong> của &lt;strong>function&lt;/strong> đó sẽ được &lt;strong>pop&lt;/strong> ra khỏi &lt;strong>execution context&lt;/strong>,và &lt;strong>statement pointer&lt;/strong> sẽ quay về vị trí đã gọi &lt;strong>function&lt;/strong> vừa hoàn thành, tiếp tục công việc thực thi từng dùng. &lt;strong>Execution stack&lt;/strong> đảm bảo được rằng các được gọi sau (trong các hàm bất kỳ) hoàn thành trước để đảm bảo tính đúng đắn của chương trình.&lt;/p>
&lt;p>Quy tắc tìm kiếm các &lt;strong>identifier&lt;/strong> dọc theo mối quan hệ cha - con của &lt;strong>lexical&lt;/strong> được gọi là &lt;strong>scope chain&lt;/strong>. Một điều cần chú ý đối với function là, execution context mặc định nó sẽ được bind với scope được khai báo. Tức là outer scope (outer execution context) của function khi call/invoke là nơi khai báo (chứ không phải là nơi call/invoke).&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-js" data-lang="js">&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">A&lt;/span>(){
&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">v&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;from A&amp;#39;&lt;/span>
&lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#a6e22e">v&lt;/span>)
}
&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">B&lt;/span>(){
&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">v&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;from B&amp;#39;&lt;/span>
&lt;span style="color:#a6e22e">A&lt;/span>()
}
&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">v&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;from Global&amp;#39;&lt;/span>
&lt;span style="color:#a6e22e">B&lt;/span>()
&lt;span style="color:#75715e">// from A
&lt;/span>&lt;span style="color:#75715e">// Xoá đi dòng thứ 2 thì kết quả là
&lt;/span>&lt;span style="color:#75715e">// from Global
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Xem xét ví dụ sau thì kết quả đơn giản là &lt;code>from A&lt;/code>. Tuy nhiên nếu xoá đi dòng &lt;code>let v = 'from A'&lt;/code> thì kết quả lại là &lt;code>from Global&lt;/code>. Lý do bởi vì A được khai báo ở &lt;code>global&lt;/code> chứ không phải là &lt;code>B&lt;/code>. Mặc dù được gọi ở lexical &lt;code>B&lt;/code> nhưng &lt;code>A&lt;/code> lại không thể tìm kiếm các identifiers ở lexical &lt;code>B&lt;/code>. Vậy có cách nào để &lt;code>bind&lt;/code> lexical ở nơi nó được gọi hay không? Theo mình biết thì hiện tại là &lt;code>chưa&lt;/code> ngoại trừ việc bạn viết lại một runtime engine theo ý muốn.&lt;/p>
&lt;h1 id="hoisting">Hoisting&lt;/h1>
&lt;p>&lt;strong>Hoisting&lt;/strong> (Xem thêm ở &lt;a class="link" href="https://sonlhcsuit.github.io/p/variable" >Variable&lt;/a>), tuy nhiên có một điều bổ sung nữa là. Giai đoạn &lt;strong>hoisting&lt;/strong> chỉ xảy ra khi một &lt;strong>execution context&lt;/strong> được tạo ra, và việc khai báo đè cũng chỉ ảnh hưởng trong &lt;strong>execution context&lt;/strong> đó.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">f&lt;/span>(){
&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">h&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">12&lt;/span>;
&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">a&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">22&lt;/span>
&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">g&lt;/span>(){
&lt;span style="color:#75715e">// Hoisting function =&amp;gt; bị ghi đè
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#a6e22e">h&lt;/span>)
&lt;span style="color:#75715e">// let h = 10
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">h&lt;/span>(&lt;span style="color:#a6e22e">a&lt;/span>){
&lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#a6e22e">a&lt;/span>)
&lt;span style="color:#75715e">// debugger;
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#e6db74">&amp;#39;From h w/love&amp;#39;&lt;/span>)
}
&lt;span style="color:#a6e22e">h&lt;/span>()
&lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#e6db74">&amp;#39;From g w/love&amp;#39;&lt;/span>)
}
&lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#a6e22e">h&lt;/span>)
&lt;span style="color:#a6e22e">g&lt;/span>()
&lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#a6e22e">h&lt;/span>)
&lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#e6db74">&amp;#39;From f w/love&amp;#39;&lt;/span>)
}
&lt;span style="color:#a6e22e">f&lt;/span>()
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Một vài sự chú ý nhỏ đây là trong &lt;strong>lexical&lt;/strong> của hàm &lt;strong>f&lt;/strong> thì &lt;strong>identifier&lt;/strong> &lt;strong>h&lt;/strong> đã được khai báo bằng từ khoá &lt;code>let&lt;/code>, vậy tại sao khi in &lt;strong>h&lt;/strong> ra console lại bị thay đổi? Khi sử dụng từ khoá &lt;strong>function&lt;/strong> thì &lt;strong>hoisting&lt;/strong> xảy ra, thay thế &lt;strong>identifier&lt;/strong> &lt;strong>h&lt;/strong> của hàm &lt;strong>f&lt;/strong>, thay thế bằng &lt;strong>h&lt;/strong> của hàm &lt;strong>g&lt;/strong>. Vì &lt;strong>lexical&lt;/strong> hiện tại là hàm &lt;strong>g&lt;/strong> Javascript engine sẽ chọn &lt;strong>identifier&lt;/strong> ở gần &lt;strong>lexical&lt;/strong> hiện tại nhất (là &lt;strong>idetitier&lt;/strong> &lt;strong>h&lt;/strong> của hàm &lt;strong>g&lt;/strong> chứ không phải &lt;strong>f&lt;/strong>).&lt;/p>
&lt;p>Ngoài ra thì ở dòng đầu tiên của hàm &lt;strong>h&lt;/strong>, kết quả chúng ta nhận được &lt;strong>undefined&lt;/strong> chứ không phải &lt;strong>12&lt;/strong>. Lí do là các &lt;strong>parameter&lt;/strong> cũng được khai báo bằng từ khoá &lt;strong>var&lt;/strong> giống như biến (tức là cũng xảy ra &lt;strong>hoisting&lt;/strong>). Sau đó mới được gán giá trị được truyền vào lúc được &lt;strong>invoke/call&lt;/strong>. Vậy nên giá trị của &lt;strong>a&lt;/strong> là &lt;strong>undefined&lt;/strong> (vì mới được khởi tạo) và đồng thơi cũng được copy từ &lt;strong>argument&lt;/strong> sang - tuy nhiên hàm h lại gọi với không có &lt;strong>argument&lt;/strong> nào nên các &lt;strong>parameter&lt;/strong> vẫn giữ giá trị là undefined.&lt;/p>
&lt;h1 id="callback--higher-order-function--closure">Callback / Higher Order Function / Closure&lt;/h1>
&lt;p>Trong Javascrip, function được xem là một Object (một kiểu dữ liệu).Điều này đồng nghĩa với ta có thể truyền một function như là argument khi invoke/call một function khác, hay nó cũng có thể là một gì đó được trả về như là kết quả của việc invoke/call một function.&lt;/p>
&lt;p>Những function được truyền như argument khi invoke/call một function khác thì có tên là callback. Những function không thể được truyền như callback thì được gọi là first-class function hay là higher order function.&lt;/p>
&lt;p>Closure là khả năng ghi nhớ, kết hợp &lt;strong>lexical&lt;/strong> giữa các hàm được trả về/ callback / listener. Thay vì tìm kiếm identifier ở global lexical thì function y sẽ tìm kiếm ở lexical mà được khai báo trước (tức là lexical của function x) rồi mới tới &lt;strong>lexical&lt;/strong> hiện tại (nơi mà function được invoke/call)&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">x&lt;/span>(){
&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">y&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;hihihi&amp;#39;&lt;/span>
&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">u&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;huhuhu&amp;#39;&lt;/span>
&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">z&lt;/span>(){
&lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#a6e22e">y&lt;/span>)
&lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#a6e22e">u&lt;/span>)
}
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">z&lt;/span>
}
&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">u&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;?&amp;#39;&lt;/span>
&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">y&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">x&lt;/span>()
&lt;span style="color:#a6e22e">y&lt;/span>()
&lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#a6e22e">u&lt;/span>)
&lt;span style="color:#75715e">// hihih
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Ngoài ra, có một ví dụ cổ điển việc closure/lexical ở MDN, mình trích dẫn nó ở đây. Hãy tự suy nghĩ xem cách giải quyết và lý giải rằng lại sao nó lại như thế nhé (cần biết về lexical/scope chain/ closure)&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-html" data-lang="html">&amp;lt;&lt;span style="color:#f92672">p&lt;/span> &lt;span style="color:#a6e22e">id&lt;/span>&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;help&amp;#34;&lt;/span>&amp;gt;Helpful notes will appear here&amp;lt;/&lt;span style="color:#f92672">p&lt;/span>&amp;gt;
&amp;lt;&lt;span style="color:#f92672">p&lt;/span>&amp;gt;E-mail: &amp;lt;&lt;span style="color:#f92672">input&lt;/span> &lt;span style="color:#a6e22e">type&lt;/span>&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;text&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">id&lt;/span>&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;email&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">name&lt;/span>&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;email&amp;#34;&lt;/span>&amp;gt;&amp;lt;/&lt;span style="color:#f92672">p&lt;/span>&amp;gt;
&amp;lt;&lt;span style="color:#f92672">p&lt;/span>&amp;gt;Name: &amp;lt;&lt;span style="color:#f92672">input&lt;/span> &lt;span style="color:#a6e22e">type&lt;/span>&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;text&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">id&lt;/span>&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;name&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">name&lt;/span>&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;name&amp;#34;&lt;/span>&amp;gt;&amp;lt;/&lt;span style="color:#f92672">p&lt;/span>&amp;gt;
&amp;lt;&lt;span style="color:#f92672">p&lt;/span>&amp;gt;Age: &amp;lt;&lt;span style="color:#f92672">input&lt;/span> &lt;span style="color:#a6e22e">type&lt;/span>&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;text&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">id&lt;/span>&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;age&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">name&lt;/span>&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;age&amp;#34;&lt;/span>&amp;gt;&amp;lt;/&lt;span style="color:#f92672">p&lt;/span>&amp;gt;
&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-js" data-lang="js">&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">showHelp&lt;/span>(&lt;span style="color:#a6e22e">help&lt;/span>) {
document.&lt;span style="color:#a6e22e">getElementById&lt;/span>(&lt;span style="color:#e6db74">&amp;#39;help&amp;#39;&lt;/span>).&lt;span style="color:#a6e22e">textContent&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">help&lt;/span>;
}
&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">setupHelp&lt;/span>() {
&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">helpText&lt;/span> &lt;span style="color:#f92672">=&lt;/span> [
{&lt;span style="color:#e6db74">&amp;#39;id&amp;#39;&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">&amp;#39;email&amp;#39;&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;help&amp;#39;&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">&amp;#39;Your e-mail address&amp;#39;&lt;/span>},
{&lt;span style="color:#e6db74">&amp;#39;id&amp;#39;&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">&amp;#39;name&amp;#39;&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;help&amp;#39;&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">&amp;#39;Your full name&amp;#39;&lt;/span>},
{&lt;span style="color:#e6db74">&amp;#39;id&amp;#39;&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">&amp;#39;age&amp;#39;&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;help&amp;#39;&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">&amp;#39;Your age (you must be over 16)&amp;#39;&lt;/span>}
];
&lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">i&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; &lt;span style="color:#a6e22e">i&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span> &lt;span style="color:#a6e22e">helpText&lt;/span>.&lt;span style="color:#a6e22e">length&lt;/span>; &lt;span style="color:#a6e22e">i&lt;/span>&lt;span style="color:#f92672">++&lt;/span>) {
&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">item&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">helpText&lt;/span>[&lt;span style="color:#a6e22e">i&lt;/span>];
document.&lt;span style="color:#a6e22e">getElementById&lt;/span>(&lt;span style="color:#a6e22e">item&lt;/span>.&lt;span style="color:#a6e22e">id&lt;/span>).&lt;span style="color:#a6e22e">onfocus&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">function&lt;/span>() {
&lt;span style="color:#a6e22e">showHelp&lt;/span>(&lt;span style="color:#a6e22e">item&lt;/span>.&lt;span style="color:#a6e22e">help&lt;/span>);
}
}
}
&lt;span style="color:#a6e22e">setupHelp&lt;/span>();
&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="call--invoke">Call / Invoke&lt;/h1>
&lt;p>Invoke là việc gọi trực tiếp một hàm bằng việc dùng tên &lt;code>f()&lt;/code>. Call là sử dụng HOF để invoke hàm đó bằng cách gián tiếp&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-js" data-lang="js">&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">g&lt;/span>(&lt;span style="color:#a6e22e">callback&lt;/span>){
&lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#e6db74">&amp;#39;From g w/love&amp;#39;&lt;/span>)
&lt;span style="color:#a6e22e">cb&lt;/span>()
}
&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">h&lt;/span>(){
&lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#e6db74">&amp;#39;From h w/love&amp;#39;&lt;/span>)
}
&lt;span style="color:#a6e22e">g&lt;/span>(&lt;span style="color:#a6e22e">h&lt;/span>)
&lt;span style="color:#75715e">// invoke g, but g call h instead us
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;hr>
&lt;h1 id="references--more-resources">References &amp;amp; more resources&lt;/h1>
&lt;ul>
&lt;li>&lt;a class="link" href="https://www.britannica.com/science/function-mathematics" target="_blank" rel="noopener"
>https://www.britannica.com/science/function-mathematics&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://stackoverflow.com/questions/50884893/calling-vs-invoking-a-function" target="_blank" rel="noopener"
>https://stackoverflow.com/questions/50884893/calling-vs-invoking-a-function&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://www.w3schools.com/js/js_function_definition.asp" target="_blank" rel="noopener"
>https://www.w3schools.com/js/js_function_definition.asp&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://stackoverflow.com/questions/12599965/lexical-environment-and-function-scope" target="_blank" rel="noopener"
>https://stackoverflow.com/questions/12599965/lexical-environment-and-function-scope&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures" target="_blank" rel="noopener"
>https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures&lt;/a>&lt;/li>
&lt;/ul>
&lt;h3 id="ps">P/S:&lt;/h3>
&lt;p>Có thể tuỳ thuộc vào các engine có một cách thực thi Javascript khác nhau nên có gì sai sót xin email cho mình để mình cập nhật. Xin cảm ơn!&lt;/p></description></item><item><title>Variable</title><link>https://sonlhcsuit.github.io/p/variable/</link><pubDate>Mon, 12 Apr 2021 19:01:17 +0700</pubDate><guid>https://sonlhcsuit.github.io/p/variable/</guid><description>&lt;img src="https://sonlhcsuit.github.io/p/variable/cover.png" alt="Featured image of post Variable" />&lt;h1 id="variable">Variable&lt;/h1>
&lt;p>Biến là một khái niệm rất quan trọng trong nhiều ngôn ngữ lập trình, được sử dụng để lưu trữ các giá trị. Chúng ta có thể gán một giá trị cho một biến, khi nào cần giá trị cho việc tính toán (số, chuỗi, etc.) thì sử dụng tên biến thay vì giá trị, các &lt;em>interpreter&lt;/em>, &lt;em>compiler&lt;/em> truy xuất đến giá trị đã được gán vào biến, thay thế vào biểu thức và thực hiện việc tính toán. Con người dễ tiếp thu ngôn ngữ hơn là những giá trị hoặc con số, biến là một ánh xạ đơn giản, &lt;strong>một từ&lt;/strong> sinh ra &lt;strong>giá trị&lt;/strong>. Tên của biến phải là độc nhất theo những quy tắc đặt tên của các ngôn ngữ lập trình, một biến chỉ lưu trữ một giá trị tại 1 thời điểm nhất định.&lt;/p>
&lt;p>Thoát khỏi việc ghi nhớ các giá trị bằng cách sử dụng biến, các lập trình viên lại có thêm vài vấn đề như sau: Đặt tên biến như thế nào để ngắn gọn, dễ nhớ? Muốn nhiều biến có cùng tên được không? etc. Nhằm giải quyết vấn đề về &lt;em>cách đặt tên biến&lt;/em>, các ngôn ngữ lập trình đã hỗ trợ thêm những khái niệm &lt;em>lexical, scope,&amp;hellip;&lt;/em>&lt;/p>
&lt;h1 id="variable-naming">Variable naming&lt;/h1>
&lt;p>Nói về việc đặt tên biến thì có nhiều quy tắc&lt;/p>
&lt;ul>
&lt;li>Tối thiểu:
&lt;ul>
&lt;li>Tên của một biến phải độc nhất trong một phạm vi nhất định&lt;/li>
&lt;li>Bao gồm các ký tự trong bảng chữ cái (cả thường và hoa), số, ký tự đặc biệt cho phép tuỳ theo mỗi ngôn ngữ lập trình (JS thì chỉ cho phép 2 ký tự là &amp;ldquo;_&amp;rdquo; và &amp;ldquo;$&amp;quot;)&lt;/li>
&lt;li>Không được trùng với các reserved word (keyword)&lt;/li>
&lt;li>Không được bắt đầu bằng số&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Nên có:
&lt;ul>
&lt;li>Ít mang động từ&lt;/li>
&lt;li>Ngắn ngọn, súc tích, có nghĩa&lt;/li>
&lt;li>Sử dụng cách nối (như kebab case, snake case, camel case,etc.) khi có nhiều hơn 2 từ&lt;/li>
&lt;li>&amp;hellip;&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>Và quan trọng hơn hết là phải tuân thủ cú pháp để khai báo biến của từng ngôn ngữ lập trình!&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-js" data-lang="js">&lt;span style="color:#75715e">// ở trong javascript, chúng ta có 3 cách khai báo biến
&lt;/span>&lt;span style="color:#75715e">// bằng viêc sử dụng 3 reserved word như var, let, const
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">revenues&lt;/span>;
&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">costs&lt;/span>;
&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">profits&lt;/span>;
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Vốn từ vựng nhiều là một lợi thế khi đặt tên biến, tuy nhiên chúng ta không đặt tên biến khác nhau hoàn toàn. Nếu đặt tên biến khác nhau hoàn toàn thì sẽ có rất nhiều biến, việc nhớ chúng sẽ rất tốn thời gian. Thay vì đó, các ngôn ngữ lập trình hỗ trợ các khái niệm &lt;em>idetifier, scope, lexical,etc.&lt;/em> để giúp chúng ta tiết kiệm thời gian, công sức.&lt;/p>
&lt;h1 id="identifier--access-scope">Identifier &amp;amp; access scope&lt;/h1>
&lt;p>Biến là một &lt;strong>identifier&lt;/strong>, tức là định danh (&lt;strong>identifier&lt;/strong> còn có thể các &lt;strong>function&lt;/strong>, &lt;strong>class&lt;/strong>,etc). Chúng ta có thể khởi tạo (tạo ra) nhiều biến có cùng tên, lưu trữ các giá trị khác nhau ở các &lt;strong>scope&lt;/strong> khác nhau. Trình duyệt sẽ dựa vào &lt;strong>scope&lt;/strong>, xác định &lt;strong>identifier&lt;/strong> và giá trị của chúng phù hợp. Các &lt;strong>identifier&lt;/strong> khi được khởi tạo luôn được gắn chặt với &lt;strong>scope&lt;/strong> nơi mà chúng được khởi tạo. Chúng ta chỉ có thể truy cập tới các &lt;strong>identifier&lt;/strong> ở các &lt;strong>outer scope&lt;/strong>, không đối với &lt;strong>inner scope&lt;/strong>. &lt;strong>Scope&lt;/strong> có phạm vi truy cập lớn nhất &lt;strong>Global Scope&lt;/strong>.&lt;/p>
&lt;p>Sự khác biệt giữa &lt;strong>let&lt;/strong> &amp;amp; &lt;strong>var&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-js" data-lang="js">&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">revenues&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">100000&lt;/span>;
&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">costs&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">12345&lt;/span>
&lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#a6e22e">revenue&lt;/span> &lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> ){
&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">profits&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">revenues&lt;/span> &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#a6e22e">costs&lt;/span>
}
&lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#a6e22e">profits&lt;/span>)
&lt;span style="color:#75715e">// ReferenceError: profits is not defined
&lt;/span>&lt;span style="color:#75715e">// Hàm console ở global scope truy cập tới biến profits,
&lt;/span>&lt;span style="color:#75715e">// tuy nhiên biến profits được khởi tạo ở scope của if (inner scope),
&lt;/span>&lt;span style="color:#75715e">// nên việc truy cập thất bại. Tuy nhiên việc truy cập
&lt;/span>&lt;span style="color:#75715e">// revenues &amp;amp; costs đều thành công khi ở trong scope của if vì
&lt;/span>&lt;span style="color:#75715e">// đối vời scope của if thì global là outer scope
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Khi thực hiện việc tìm kiếm các &lt;strong>identifier&lt;/strong> thì ta sẽ tuân theo quy tắc từ trong ra ngoài. Javascript sẽ xét ở scope hiện tại, sau đó chuyện tới outer scope, xét tiếp, tiếp tục chuyển tới outer scope,&amp;hellip; cho tới khi gặp được &lt;strong>identifier&lt;/strong> hợp lệ hoặc tới global scope mà không tìm được thì sẽ báo lỗi (Cách tìm kiếm &lt;strong>identifier&lt;/strong> được gọi là &lt;strong>scopes chain&lt;/strong>). Đối với từ khoá &lt;code>let&lt;/code> thì quy tắc &lt;strong>scopes chain&lt;/strong> đúng hoàn toàn, và nhiều ngôn ngữ khác cũng vậy. Tuy nhiên điều này không hoàn toàn đúng với &lt;code>var&lt;/code>.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-js" data-lang="js">&lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#66d9ef">true&lt;/span>){
&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">z&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">100&lt;/span>
}
&lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#a6e22e">z&lt;/span>)
&lt;span style="color:#75715e">// 100
&lt;/span>&lt;span style="color:#75715e">// Điều này chứng mình rằng khi khai báo var, quy tắc scope chain
&lt;/span>&lt;span style="color:#75715e">// không còn chính xác nữa
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>var&lt;/code> đặc biệt hơn với &lt;code>let&lt;/code> ở chỗ nó không tuân theo quy tắc chung. Chúng ta có thể kết luận rằng, khi khai báo &lt;strong>identifier&lt;/strong> với từ khoá &lt;code>var&lt;/code> sẽ có scope là global không? Tất nhiên là không!&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-js" data-lang="js">&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">initialVariable&lt;/span>() {
&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">z&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;this is z&amp;#39;&lt;/span>
&lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#a6e22e">z&lt;/span>)
}
&lt;span style="color:#a6e22e">initialVariable&lt;/span>()
&lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#a6e22e">z&lt;/span>)
&lt;span style="color:#75715e">// this is z
&lt;/span>&lt;span style="color:#75715e">// ReferenceError: z is not defined
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Vậy nên ta không thể kết luận rằng &lt;strong>khai báo identifier với từ khoá &lt;code>var&lt;/code> sẽ có scope là global&lt;/strong>. Vậy thì lí do tại sao ví dụ ở trên lại bị sai nhỉ? Câu trả lời là đối với &lt;strong>scope&lt;/strong> của hàm thì có một chút khác biệt, có tên là &lt;strong>lexical&lt;/strong>. Khi khai báo &lt;strong>identifier&lt;/strong> bằng &lt;code>var&lt;/code>, thay vì &lt;strong>bind&lt;/strong> vào scope, thì &lt;strong>identifier&lt;/strong> được &lt;strong>bind&lt;/strong> vào &lt;strong>lexical&lt;/strong>. Ngoại trừ điều đó ra thì &lt;code>var&lt;/code> còn có khả năng &lt;strong>redeclarion&lt;/strong> (tái khai báo) mà không gặp lỗi. (làm với &lt;code>let&lt;/code> thì sẽ gặp lỗi &lt;code>SyntaxError: Identifier _ has already been declared&lt;/code>)&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-js" data-lang="js">&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">z&lt;/span> &lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#39;this is z at first&amp;#39;&lt;/span>
&lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#a6e22e">z&lt;/span>)
&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">initialVariable&lt;/span>() {
&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">z&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;this is z&amp;#39;&lt;/span>
&lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#a6e22e">z&lt;/span>)
&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">z&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;this is z but 4th&amp;#39;&lt;/span> &lt;span style="color:#75715e">// redeclaration
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#a6e22e">z&lt;/span>)
}
&lt;span style="color:#a6e22e">initialVariable&lt;/span>()
&lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#a6e22e">z&lt;/span>)
&lt;span style="color:#75715e">// this is z at first
&lt;/span>&lt;span style="color:#75715e">// this is z
&lt;/span>&lt;span style="color:#75715e">// this is z but 4th
&lt;/span>&lt;span style="color:#75715e">// this is z at first
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Xét thêm trường hợp này&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-js" data-lang="js">&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">z&lt;/span>&lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1000&lt;/span>
&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">f&lt;/span>() {
&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">fs&lt;/span> &lt;span style="color:#f92672">=&lt;/span> []
&lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">i&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; &lt;span style="color:#a6e22e">i&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">5&lt;/span>; &lt;span style="color:#a6e22e">i&lt;/span>&lt;span style="color:#f92672">++&lt;/span>) {
&lt;span style="color:#a6e22e">fs&lt;/span>.&lt;span style="color:#a6e22e">push&lt;/span>(&lt;span style="color:#66d9ef">function&lt;/span> () {
&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">z&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">i&lt;/span>
&lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#a6e22e">z&lt;/span>)
})
}
&lt;span style="color:#a6e22e">fs&lt;/span>[&lt;span style="color:#ae81ff">3&lt;/span>]()
}
&lt;span style="color:#a6e22e">f&lt;/span>()
&lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#a6e22e">z&lt;/span>)
&lt;span style="color:#75715e">// 5
&lt;/span>&lt;span style="color:#75715e">// i được khai báo ở lexical f, khi thực hiện vòng lặp với post operator là i++ thì
&lt;/span>&lt;span style="color:#75715e">// đang thay đổi giá trị của biến i ở lexical f.
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Ngoại trừ việc &lt;strong>bind&lt;/strong> khác một chút &lt;code>var&lt;/code> vẫn tuân theo quy tắc của &lt;strong>scope chain&lt;/strong>. Có nhiều bạn tưởng rằng &lt;code>var&lt;/code> sẽ tạo một property ở global object (cụ thể window ) - chưa hoàn toàn đúng, chỉ khi nào bạn khai báo bằng &lt;code>var&lt;/code> ở global scope thì mới tạo property, còn lại thì không.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-js" data-lang="js">&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">f&lt;/span>() {
&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">z&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;111&amp;#39;&lt;/span>
&lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#a6e22e">z&lt;/span>)
&lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(window.&lt;span style="color:#a6e22e">z&lt;/span>)
}
&lt;span style="color:#a6e22e">f&lt;/span>()
&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="const">&lt;code>const&lt;/code>&lt;/h1>
&lt;p>Điều khiến &lt;strong>identifier&lt;/strong> đặc biệt là không cho phép &lt;strong>direct assignment&lt;/strong>. Assignment là một toán tử cho phép cập nhật &lt;strong>giá trị&lt;/strong> đã được lưu trữ của &lt;strong>identifier&lt;/strong>.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-js" data-lang="js">&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">z&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">100&lt;/span>;
&lt;span style="color:#a6e22e">z&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;??&amp;#39;&lt;/span>
&lt;span style="color:#75715e">// TypeError: Assignment to constant variable.
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Tuy nhiên ,việc thay đổi nội tại bên trong, hoặc thay đổi thông qua trung gian vẫn có thể.(Đối với references data type)&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-js" data-lang="js">&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">z&lt;/span> &lt;span style="color:#f92672">=&lt;/span> []
&lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#a6e22e">z&lt;/span>)
&lt;span style="color:#a6e22e">z&lt;/span>.&lt;span style="color:#a6e22e">push&lt;/span>(&lt;span style="color:#ae81ff">1&lt;/span>,&lt;span style="color:#ae81ff">2&lt;/span>,&lt;span style="color:#ae81ff">3&lt;/span>,&lt;span style="color:#ae81ff">4&lt;/span>)
&lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#a6e22e">z&lt;/span>)
&lt;span style="color:#75715e">// []
&lt;/span>&lt;span style="color:#75715e">// (4) [1, 2, 3, 4]
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-js" data-lang="js">&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">z&lt;/span> &lt;span style="color:#f92672">=&lt;/span> {}
&lt;span style="color:#a6e22e">z&lt;/span>.&lt;span style="color:#a6e22e">name&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;z&amp;#39;&lt;/span>
&lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#a6e22e">z&lt;/span>)
&lt;span style="color:#75715e">// {name: &amp;#34;z&amp;#34;}
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="hoisting--tempotary-dead-zone">Hoisting &amp;amp; Tempotary Dead Zone&lt;/h1>
&lt;p>Một &lt;strong>identifier&lt;/strong> được khỏi tạo thông qua 1 hoặc 2 giai đoạn : &lt;strong>declaration&lt;/strong> (&lt;strong>defination&lt;/strong>) và &lt;strong>initialization&lt;/strong>. Giai đoạn 2 có thể có hoặc không. &lt;strong>declaration&lt;/strong> mang ý nghĩa cấp vùng nhớ dùng để lưu giá trị và &lt;strong>bind identifier&lt;/strong> với giá trị có sẵn ở vùng nhớ(C++), &lt;strong>initialization&lt;/strong> mang ý nghĩa khởi tạo cho giá trị ban đầu là bao nhiêu. Nếu không có &lt;strong>initialization&lt;/strong> thì giá trị mạc định là &lt;strong>undefined&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-js" data-lang="js">&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">z&lt;/span>;
&lt;span style="color:#75715e">// declaration
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">z&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">100&lt;/span>;
&lt;span style="color:#75715e">// declaration + initialization
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Hãy xem xét các ví dụ sau:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-js" data-lang="js">&lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#a6e22e">z&lt;/span>)
&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">z&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">10&lt;/span>;
&lt;span style="color:#75715e">// ReferenceError: Cannot access &amp;#39;z&amp;#39; before initialization
&lt;/span>&lt;span style="color:#75715e">// Chúng ta đã sử dụng biến z trước khi nó được khai báo, đây được gọi là tdz
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-js" data-lang="js">&lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#a6e22e">z&lt;/span>)
&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">z&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">10&lt;/span>;
&lt;span style="color:#75715e">// undefined
&lt;/span>&lt;span style="color:#75715e">// Nếu thay let bằng var thì ta lại nhận được giá trị. Đây là ví dụ cho việc hoisting
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Tempotary Dead Zone là khái niệm dùng để nói về việc sử dụng một &lt;strong>identifier&lt;/strong> trước khi được tạo ra.Hoisting áp dụng đối với &lt;strong>identifier&lt;/strong> được khai báo bằng từ khoá &lt;code>var&lt;/code> và &lt;code>function&lt;/code>. Hoisting chỉ hiệu quả trong một &lt;strong>lexical&lt;/strong>. Hoisting nghĩa là Javascript sẽ đem tất cả các biến phù hợp ( khai báo bằng &lt;code>var&lt;/code> và &lt;code>function&lt;/code>), thực hiện việc &lt;strong>declaration&lt;/strong> trước, khi đến dòng thực sự khai báo, chỉ phải thực hiện assignment mà thôi.&lt;/p>
&lt;p>TDZ không phải ám chỉ thứ tự khai báo các biến và sử dụng, mà thường dùng để nói về thứ tự thực thi (Execution Order). Miễn là tại thời điểm thực thi các biến đã được khởi là là ổn. TDZ thường hay đề cập đối với &lt;code>let&lt;/code> hơn là &lt;code>var&lt;/code> (&lt;code>var&lt;/code> sẽ Javascript áp dụng hoisting nên chuyện chưa được khởi tạo không xảy ra - chỉ có vấn đề là giá trị là undefined mà thôi). Để khắc phục tình trạng một biến gặp trường hợp &lt;strong>tdz&lt;/strong> thì nên cân nhắc đem tất cả các biến lên khai báo ở đầu scope/lexical&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-js" data-lang="js">&lt;span style="color:#66d9ef">if&lt;/span>(&lt;span style="color:#66d9ef">true&lt;/span>){
&lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#a6e22e">z&lt;/span>);
&lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#a6e22e">x&lt;/span>);
&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">z&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;this is z&amp;#39;&lt;/span>;
&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">x&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;this is x&amp;#39;&lt;/span>;
}
&lt;span style="color:#75715e">// undefined
&lt;/span>&lt;span style="color:#75715e">// ReferenceError: Cannot access &amp;#39;x&amp;#39; before initialization
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-js" data-lang="js">&lt;span style="color:#75715e">// Đây là ví dụ về thực thi
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#66d9ef">true&lt;/span>){
&lt;span style="color:#75715e">//
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">f&lt;/span>(){
&lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#a6e22e">z&lt;/span>)
}
&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">z&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;this is z&amp;#39;&lt;/span>
}
&lt;span style="color:#a6e22e">f&lt;/span>() &lt;span style="color:#75715e">//
&lt;/span>&lt;span style="color:#75715e">// this is z
&lt;/span>&lt;span style="color:#75715e">// this is z - khi khai hàm bằng function =&amp;gt; giống như var
&lt;/span>&lt;span style="color:#75715e">// bind thẳng lexical chứ không phải scope - arrow function
&lt;/span>&lt;span style="color:#75715e">// khắc phục được điểm này
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Khi bạn sử dụng các từ khoá để khởi tạo các &lt;strong>identifier&lt;/strong>, thì các &lt;strong>identifier&lt;/strong> được bind vào scope/lexical tuỳ thuộc vào nơi khai báo. Nhưng &lt;strong>nếu&lt;/strong> bạn không khai báo biến mà trực tiếp &lt;strong>assignment&lt;/strong> thì mặc định Javascript sẽ làm tự động tạo cho bạn 1 biến ở &lt;strong>global scope&lt;/strong> (Nếu chưa tồn tại ở &lt;strong>scope chain&lt;/strong> dẫn ra &lt;strong>global scope&lt;/strong>)&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-js" data-lang="js">&lt;span style="color:#a6e22e">x&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;this is x&amp;#39;&lt;/span>;
&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">f&lt;/span>() {
&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">g&lt;/span>(){
&lt;span style="color:#a6e22e">z&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;this is z lexical of g&amp;#39;&lt;/span>
}
&lt;span style="color:#a6e22e">g&lt;/span>()
}
&lt;span style="color:#a6e22e">f&lt;/span>();
&lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#a6e22e">globalThis&lt;/span>)
&lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#a6e22e">x&lt;/span>, &lt;span style="color:#a6e22e">z&lt;/span>);
&lt;span style="color:#75715e">// this is x this is z lexical of g
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;hr>
&lt;h1 id="references--more-resources">References &amp;amp; more resources&lt;/h1>
&lt;ul>
&lt;li>&lt;a class="link" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let" target="_blank" rel="noopener"
>https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/var" target="_blank" rel="noopener"
>https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/var&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/const" target="_blank" rel="noopener"
>https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/const&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference" target="_blank" rel="noopener"
>https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference&lt;/a>&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="ps">P/S:&lt;/h3>
&lt;p>Các đoạn code ở trên được mình chạy ở trên engine V8 của Chrome thông qua trình duyệt Brave. Có thể tuỳ thuộc vào các engine có một cách thực thi Javascript khác nhau nên có gì sai sót xin email cho mình để mình cập nhật. Xin cảm ơn!&lt;/p></description></item><item><title>Event Bubbling &amp; Capturing</title><link>https://sonlhcsuit.github.io/p/event-bubbles/</link><pubDate>Wed, 31 Mar 2021 11:14:24 +0700</pubDate><guid>https://sonlhcsuit.github.io/p/event-bubbles/</guid><description>&lt;img src="https://sonlhcsuit.github.io/p/event-bubbles/cover.png" alt="Featured image of post Event Bubbling &amp; Capturing" />&lt;p>Khi xử lý với Event thông qua DOM ở trong Javascript, cần phải hiểu một chút kỹ càng về cách các event hoạt động. Mỗi khi một event được &lt;strong>trigger&lt;/strong>, bắt đầu thực thi &lt;strong>listener&lt;/strong> thì cùng lúc cũng có nhiều &lt;strong>listener&lt;/strong> được kích hoạt cùng lúc. Có các cơ chế để trình duyệt thực hiện những &lt;strong>listener&lt;/strong> theo một thứ tự xác định. Các cơ chế cơ bản đó là bubble &amp;amp; capturing.&lt;/p>
&lt;p>Xem xét các ví dụ sau đây về độ sâu (depth) của cây DOM thông qua đoạn HTML&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-html" data-lang="html">&amp;lt;&lt;span style="color:#f92672">div&lt;/span> &lt;span style="color:#a6e22e">class&lt;/span>&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;box box-1&amp;#34;&lt;/span>&amp;gt;
&amp;lt;&lt;span style="color:#f92672">div&lt;/span> &lt;span style="color:#a6e22e">class&lt;/span>&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;box box-2&amp;#34;&lt;/span>&amp;gt;
&amp;lt;&lt;span style="color:#f92672">div&lt;/span> &lt;span style="color:#a6e22e">class&lt;/span>&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;box box-3&amp;#34;&lt;/span>&amp;gt;
&amp;lt;/&lt;span style="color:#f92672">div&lt;/span>&amp;gt;
&amp;lt;/&lt;span style="color:#f92672">div&lt;/span>&amp;gt;
&amp;lt;/&lt;span style="color:#f92672">div&lt;/span>&amp;gt;
&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-css" data-lang="css">&lt;span style="color:#f92672">*&lt;/span>{
&lt;span style="color:#66d9ef">margin&lt;/span>: &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;span style="color:#66d9ef">padding&lt;/span>: &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;span style="color:#66d9ef">box-sizing&lt;/span>: &lt;span style="color:#66d9ef">border-box&lt;/span>;
}
.&lt;span style="color:#a6e22e">box&lt;/span> {
&lt;span style="color:#66d9ef">display&lt;/span>: &lt;span style="color:#66d9ef">block&lt;/span>;
&lt;span style="color:#66d9ef">margin&lt;/span>:&lt;span style="color:#ae81ff">20&lt;/span>&lt;span style="color:#66d9ef">px&lt;/span>;
}
.&lt;span style="color:#a6e22e">box&lt;/span>.&lt;span style="color:#a6e22e">box-1&lt;/span>{
&lt;span style="color:#66d9ef">width&lt;/span>: &lt;span style="color:#ae81ff">40&lt;/span>&lt;span style="color:#66d9ef">vh&lt;/span>;
&lt;span style="color:#66d9ef">height&lt;/span>: &lt;span style="color:#ae81ff">40&lt;/span>&lt;span style="color:#66d9ef">vh&lt;/span>;
&lt;span style="color:#66d9ef">border&lt;/span>: &lt;span style="color:#66d9ef">solid&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>&lt;span style="color:#66d9ef">px&lt;/span> &lt;span style="color:#66d9ef">red&lt;/span>;
}
.&lt;span style="color:#a6e22e">box&lt;/span>.&lt;span style="color:#a6e22e">box-2&lt;/span>{
&lt;span style="color:#66d9ef">width&lt;/span>: &lt;span style="color:#ae81ff">30&lt;/span>&lt;span style="color:#66d9ef">vh&lt;/span>;
&lt;span style="color:#66d9ef">height&lt;/span>: &lt;span style="color:#ae81ff">30&lt;/span>&lt;span style="color:#66d9ef">vh&lt;/span>;
&lt;span style="color:#66d9ef">border&lt;/span>: &lt;span style="color:#66d9ef">solid&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>&lt;span style="color:#66d9ef">px&lt;/span> &lt;span style="color:#66d9ef">black&lt;/span>;
}
.&lt;span style="color:#a6e22e">box&lt;/span>.&lt;span style="color:#a6e22e">box-3&lt;/span>{
&lt;span style="color:#66d9ef">width&lt;/span>: &lt;span style="color:#ae81ff">20&lt;/span>&lt;span style="color:#66d9ef">vh&lt;/span>;
&lt;span style="color:#66d9ef">height&lt;/span>: &lt;span style="color:#ae81ff">20&lt;/span>&lt;span style="color:#66d9ef">vh&lt;/span>;
&lt;span style="color:#66d9ef">border&lt;/span>: &lt;span style="color:#66d9ef">solid&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>&lt;span style="color:#66d9ef">px&lt;/span> &lt;span style="color:#66d9ef">blue&lt;/span>;
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Khi hiển thị trên trình duyệt thì kết quả sẽ gồm 3 hình vuông lớn nhỏ theo kích thước và thứ tự sau:
&lt;figure style="flex-grow: 153; flex-basis: 367px">
&lt;a href="https://sonlhcsuit.github.io/p/event-bubbles/pic-1.png" data-size="1338x874">&lt;img src="https://sonlhcsuit.github.io/p/event-bubbles/pic-1.png"
srcset="https://sonlhcsuit.github.io/p/event-bubbles/pic-1_hu36b15a2e5c4bbafff2e4a73ac93e0b68_42228_480x0_resize_box_3.png 480w, https://sonlhcsuit.github.io/p/event-bubbles/pic-1_hu36b15a2e5c4bbafff2e4a73ac93e0b68_42228_1024x0_resize_box_3.png 1024w"
width="1338"
height="874"
loading="lazy"
alt="Hiển thị đoạn của code ở phía trên">
&lt;/a>
&lt;figcaption>Hiển thị đoạn của code ở phía trên&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>Box 3 - nằm trong Box 2 - nằm trong Box 1. Sử dụng một chút logic thì ta cũng có thể nhận thấy rằng khi người dùng click vào Box 3 thì cũng là người dùng click vào Box 2 và Box 1 (bởi vì Box 2 và Box 1 có kích thước lớn hơn và Box 3 nằm ở bên trong)&lt;/p>
&lt;p>Nếu chúng ta thêm các &lt;strong>listener&lt;/strong> vào event click, thì khi event được trigger ở Box 3 thì các &lt;strong>listener&lt;/strong> ở Box 2, Box 1 cũng được trigger theo. Và kết quả là cả 3 &lt;strong>listener&lt;/strong> đều được thực thi. Điều này đúng với logic căn bản, tuy nhiên nếu các &lt;strong>listener&lt;/strong> này xung đột lẫn nhau (ví dụ ẩn/hiện các component thì không hợp lý chút nào ). Cần nắm rõ cơ chế lan truyền - propagation - các event.&lt;/p>
&lt;p>Có 2 cơ chế lan truyền chính của các trình duyệt hiện tại là bubble &amp;amp; capture. Nhiều trình duyệt đã chuyển sang cơ chế mặc định là bubbles - từ &amp;ldquo;dưới lên &amp;ldquo;trên&amp;rdquo;. Còn cơ chế capture sẽ ngược lại, từ &amp;ldquo;trên&amp;rdquo; xuống &amp;ldquo;dưới&amp;rdquo;.&lt;/p>
&lt;p>Đối với cơ chế capture: trình duyệt sẽ bắt đầu từ gốc của cây DOM, tìm dần xuống tới element được kích hoạt (Box 3). Để tới được Box 3 thì phải trải qua các Node sau : html -&amp;gt; body -&amp;gt; box 1 -&amp;gt; box 2 -&amp;gt; box 3. Như vậy theo cách duyệt cây này thì các &lt;strong>listener&lt;/strong> sẽ được trigger theo thứ tự trên (nếu đã được định nghĩa). Còn cơ chế bubble sẽ thực hiện ngược lại, từ node lá duyệt ngược lên gốc: box 3 -&amp;gt; box 2 -&amp;gt; box 1 -&amp;gt; body -&amp;gt; html. Và các &lt;strong>listener&lt;/strong> sẽ được kích hoạt với thứ tự trên.&lt;/p>
&lt;p>Mặc định các trình duyệt hiện đại đều sử dụng cơ chế bubble. Tuy nhiên ta có thể chỉ định sử dụng cơ chết capture bằng cách sau.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-js" data-lang="js">document.&lt;span style="color:#a6e22e">querySelectorAll&lt;/span>(&lt;span style="color:#e6db74">&amp;#39;.box&amp;#39;&lt;/span>).&lt;span style="color:#a6e22e">forEach&lt;/span>(&lt;span style="color:#a6e22e">element&lt;/span> =&amp;gt; {
&lt;span style="color:#a6e22e">element&lt;/span>.&lt;span style="color:#a6e22e">addEventListener&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;click&amp;#34;&lt;/span>, &lt;span style="color:#66d9ef">function&lt;/span> (){
&lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">classList&lt;/span>.&lt;span style="color:#a6e22e">value&lt;/span>)
})
})
&lt;span style="color:#75715e">// bubbles
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;figure style="flex-grow: 221; flex-basis: 531px">
&lt;a href="https://sonlhcsuit.github.io/p/event-bubbles/pic-2.png" data-size="474x214">&lt;img src="https://sonlhcsuit.github.io/p/event-bubbles/pic-2.png"
srcset="https://sonlhcsuit.github.io/p/event-bubbles/pic-2_hu33a54f6207db267ccf397f69cccdda5b_8851_480x0_resize_box_3.png 480w, https://sonlhcsuit.github.io/p/event-bubbles/pic-2_hu33a54f6207db267ccf397f69cccdda5b_8851_1024x0_resize_box_3.png 1024w"
width="474"
height="214"
loading="lazy"
alt="Cơ chế bubble">
&lt;/a>
&lt;figcaption>Cơ chế bubble&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-js" data-lang="js">document.&lt;span style="color:#a6e22e">querySelectorAll&lt;/span>(&lt;span style="color:#e6db74">&amp;#39;.box&amp;#39;&lt;/span>).&lt;span style="color:#a6e22e">forEach&lt;/span>(&lt;span style="color:#a6e22e">element&lt;/span> =&amp;gt; {
&lt;span style="color:#a6e22e">element&lt;/span>.&lt;span style="color:#a6e22e">addEventListener&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;click&amp;#34;&lt;/span>, &lt;span style="color:#66d9ef">function&lt;/span>() {
&lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">classList&lt;/span>.&lt;span style="color:#a6e22e">value&lt;/span>)
}, { &lt;span style="color:#a6e22e">capture&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">true&lt;/span> })
})
&lt;span style="color:#75715e">// capture
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;figure style="flex-grow: 213; flex-basis: 511px">
&lt;a href="https://sonlhcsuit.github.io/p/event-bubbles/pic-3.png" data-size="550x258">&lt;img src="https://sonlhcsuit.github.io/p/event-bubbles/pic-3.png"
srcset="https://sonlhcsuit.github.io/p/event-bubbles/pic-3_hua5307662f227eb14e7aaa5c68edc7b51_10014_480x0_resize_box_3.png 480w, https://sonlhcsuit.github.io/p/event-bubbles/pic-3_hua5307662f227eb14e7aaa5c68edc7b51_10014_1024x0_resize_box_3.png 1024w"
width="550"
height="258"
loading="lazy"
alt="Cơ chế capture">
&lt;/a>
&lt;figcaption>Cơ chế capture&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>Tuy nhiên đôi khi chúng ta cần ngăn chặn sự lan truyền (tức là chỉ kích hoạt những listener phía trước để đảm bảo đúng dữ kiện ) bằng cách sử dụng phương thức &lt;strong>Event.stopPropagation()&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-js" data-lang="js">document.&lt;span style="color:#a6e22e">querySelectorAll&lt;/span>(&lt;span style="color:#e6db74">&amp;#39;.box&amp;#39;&lt;/span>).&lt;span style="color:#a6e22e">forEach&lt;/span>(&lt;span style="color:#a6e22e">element&lt;/span> =&amp;gt; {
&lt;span style="color:#a6e22e">element&lt;/span>.&lt;span style="color:#a6e22e">addEventListener&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;click&amp;#34;&lt;/span>, &lt;span style="color:#66d9ef">function&lt;/span>(&lt;span style="color:#a6e22e">event&lt;/span>) {
&lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">classList&lt;/span>.&lt;span style="color:#a6e22e">value&lt;/span>)
&lt;span style="color:#a6e22e">event&lt;/span>.&lt;span style="color:#a6e22e">stopPropagation&lt;/span>()
},
{
&lt;span style="color:#75715e">// capture:true
&lt;/span>&lt;span style="color:#75715e">&lt;/span> }
)
})
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;figure style="flex-grow: 173; flex-basis: 416px">
&lt;a href="https://sonlhcsuit.github.io/p/event-bubbles/pic-4.png" data-size="430x248">&lt;img src="https://sonlhcsuit.github.io/p/event-bubbles/pic-4.png"
srcset="https://sonlhcsuit.github.io/p/event-bubbles/pic-4_hu4046789cdb57c522a976de3cc6f690b0_6032_480x0_resize_box_3.png 480w, https://sonlhcsuit.github.io/p/event-bubbles/pic-4_hu4046789cdb57c522a976de3cc6f690b0_6032_1024x0_resize_box_3.png 1024w"
width="430"
height="248"
loading="lazy"
alt="Cơ chế bubble với stopPropagation">
&lt;/a>
&lt;figcaption>Cơ chế bubble với stopPropagation&lt;/figcaption>
&lt;/figure>
&lt;figure style="flex-grow: 178; flex-basis: 428px">
&lt;a href="https://sonlhcsuit.github.io/p/event-bubbles/pic-5.png" data-size="414x232">&lt;img src="https://sonlhcsuit.github.io/p/event-bubbles/pic-5.png"
srcset="https://sonlhcsuit.github.io/p/event-bubbles/pic-5_hue6344ce93fbc2e689f10c298a8dd30f4_5414_480x0_resize_box_3.png 480w, https://sonlhcsuit.github.io/p/event-bubbles/pic-5_hue6344ce93fbc2e689f10c298a8dd30f4_5414_1024x0_resize_box_3.png 1024w"
width="414"
height="232"
loading="lazy"
alt="Cơ chế capture với stopPropagation">
&lt;/a>
&lt;figcaption>Cơ chế capture với stopPropagation&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>Wednesday 31/03/2021&lt;/p></description></item><item><title>Valentine Trang</title><link>https://sonlhcsuit.github.io/p/valentine-trang/</link><pubDate>Mon, 15 Mar 2021 01:17:31 +0700</pubDate><guid>https://sonlhcsuit.github.io/p/valentine-trang/</guid><description>&lt;img src="https://sonlhcsuit.github.io/p/valentine-trang/cover.png" alt="Featured image of post Valentine Trang" />&lt;p>Hôm nay cũng như bao hôm khác, sẽ là một ngày chủ nhật thật đẹp với bầu trời xanh của thành phố quen thuộc.&lt;/p>
&lt;p>Mới vừa bước ra công ty sau một ngày chủ nhật mệt mỏi, lái trên đường về dọc kênh Nhiêu Lộc - Thị Nghè. Đang trên đường mà cứ thả hồn vào trời mây, việc lái xe thì nhường lại cho tay chân với phản xạ cơ bản.&lt;/p>
&lt;p>Không hiểu vì lí do gì mà cảm xúc trống rỗng, buồn,&amp;hellip; lấp đầy tâm trí. Không biết buồn vì điều chi, chỉ cảm thấy thiếu 1 thứ gì đó rất quan trọng.&lt;/p>
&lt;p>Càng lớn, cảm xúc tích cực càng ít đi, thay vào đó là những khoảng lặng.&lt;/p>
&lt;p>Sực nhớ ra hôm nay là valentine trắng, dường như chính cảm xúc mình lại chết một ít.&lt;/p>
&lt;p>Sunday 14/03/21&lt;/p></description></item></channel></rss>