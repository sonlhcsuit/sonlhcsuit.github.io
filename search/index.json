[{"content":"History about Programming Languages \u0026amp; Computer Chúng ta có thể khái quát lịch sử máy tính bằng bài viết khác, nhưng sau thời gian dài phát triển, thì công dụng chủ yếu của máy tính là để tính toán dựa trên input và sinh ra output. Máy tính ở thời điểm ban đầu có kích thước rất to (lớn hơn $100 m^2$), vật đổi sao dời khiến kích thước máy tính giảm dần bởi CPU (Central Processing Unit) - lõi của máy tính càng ngày càng nhỏ dựa vào công nghệ nano. Thời điểm ban đầu, CPU được chế tạo dựa trên bóng đèn dây tóc - biểu thị trạng thái bật (số 0) và tắt (số 1). Công nghệ phát triển giúp chúng ta thay thế bóng đèn bằng bóng bán dẫn nhỏ hơn bóng đèn cả nghìn lần. Nhờ vào việc thay đổi sử dụng transistor (bóng bán dẫn) vào việc chế tạo, khiến cho kích thước CPU càng ngày càng nhỏ (dẫn tới hệ quả là kích thước máy tính nhỏ dần). Một định luật có tên là Moore phát biểu rằng, cứ sau một chu kỳ thời gian nhất định thì số lượng transistor trên một đơn vị diện tích ( $cm^2$ ) sẽ tăng gấp đôi. Công nghệ nano còn có nhiều không gian để phát triển, chu kỳ của Moore\u0026rsquo;s Law là 2 năm (Đến thời gian hiện tại thì mình không dám chắc vì không biết rõ là công nghệ nano có thể đạt tới kích thước bao nhiêu. Theo thông tin tham khảo thì 1 transistor đạt kích thước 0.2 nanometer - $10^{-9}$ meter). Bởi vì lí do chỉ có thể sử dụng 2 trạng thái on/off (cho dòng điện chạy qua) của một bóng đèn / transistor nên máy tính chỉ hiểu được số nhị phân. Kết hợp các transistor và các mạch logic khiến cho CPU có thể thực hiện việc tính toán. Và computer được gọi là bởi computer bởi vì được sinh ra với mục đích là compute.\n Block Diagram of Computer \nCPU của máy tính được dựa trên những thành phần cơ bản gồm ALU (Arithmetic \u0026amp; Logic Unit - Bộ xử lý tính toán), Main Memory (Bộ nhớ chính), CU (Control Unit - Bộ điều khiển) và các thành phần khác như cache, register, et cetera. Chúng ta khiến computer thực hiện tác vụ bằng việc sử dụng instructions set ( bộ lệnh) phù hợp đã được định nghĩa sẵn bởi mỗi nhà thiết kế máy tính. Mỗi máy tính có một đặc điểm khác nhau về việc thiết kế kiến trúc, thiết kế của ALU khác nhau (cùng 1 việc thực hiện phép toán + nhưng có nhiều cách) dẫn tới việc instructions set cũng khác nhau. Developer/scientist thực hiện công việc xây dựng các chương trình hằng ngày bằng việc sử dụng instructions set bằng mã nhị phân. Điểm yếu của phương pháp này là chương trình viết trên một máy tính sẽ không chạy trên máy tính khác kiến trúc.\nCác instructions set này còn được gọi là machine language/binary language, đây là loại ngôn ngữ lập trình sơ khai nhất. Programming Language (ngôn ngữ lập trình) được tạo ra bởi con người, được sử dụng nhằm mục đích giao tiếp với máy tính, khiến cho máy tính thực hiện các hành vi do người dùng (developer/scientist) chỉ định.\nClassification of Programming Language Có rất nhiều cách để phân loại ngôn ngữ lập trình dựa trên nhiều tiêu chí. Một tiêu chí hay dùng nhất là dựa trên độ khó của việc viết, và một vài tiêu chí khác: low-level \u0026amp; high-level, hai loại ngôn ngữ này có các đặc điểm sau:\n low-level:  machine langugage assembly language   high-level: gồm các paradigm sau.  structural language procedural language object oriented language functional language    Ưu điểm của ngôn ngữ low-level rất rõ ràng: siêu nhanh, chạy trực tiếp trên CPU. Tuy nhiên yếu điểm cũng không kém cạnh: chỉ gồm bit 0 hoặ 1 (machine code) dẫn tới khó đọc, khó đọc, khó viết, dể ẩn tàng lỗi, khó bảo trì. Một điểm phát triển của assembly code so với machine code là có thể sử dụng english word (dễ nhớ) cải thiện code đáng kể. Tuy nhiên vẫn rất để lập trình, và đặc biệt là không có cấu trúc rõ ràng, chỉ gồm một list instructions. Yêu cầu cần assembler để phiên dịch assembler code thành machine code. Tuy nhiên vẫn cần assembler khác nhau dành cho mỗi máy tính\nƯu của của ngôn ngữ high-level thì không cần ai phải bàn cãi: viết code một cần, có thể chạy ở hầu hết loại máy tính. Câu lệnh tiếng anh rất dễ đọc và dễ viết, cung cấp khả năng trừu tượng. Yếu điểm là phải cần một compiler/interpreter khác nhau cho mỗi loại máy tính. Điều cần phải củng cố compiler/interpreter cho từng loại kiến trúc (x86,et cetera). Ưu điểm rất là rõ ràng, và ai cũng sử dụng high-level language nên việc phân loại tiếp theo sẽ tập trung vào các high-level language. Lưu ý việc phân loại ở đây, không phải là phân loại từng ngôn ngữ lập trình mà là phân loại các paradigm (mô hình ngôn ngữ lập trình).\nStructural Programming \u0026amp; Procedural Programming Structured Programming nghĩa là lập trình có cấu trúc, vậy thế nào là có cấu trúc? \u0026ldquo;Cấu trúc\u0026rdquo; ở đây nói về việc xử lý các dòng code một cách hợp lý bằng việc hỗ trợ thêm các khái niệm như: blocks/scopes, control flows (condition \u0026amp; repitition), subroutines. Tại sao lại hỗ trợ thêm các khái niệm này? Trước khi các khái niệm này sinh ra thì đa phần các chương trình đều viết bằng assembly nên việc sử dụng câu lệnh jump/goto là cực kỳ phổ biến. Hãy xem xét ví dụ về việc rẽ nhánh và lặp sau đây.\nmov eax,1 cmp eax,3 ; how does eax compare with 3? jl lemme_outta_here ; if it\u0026#39;s less, then jump mov eax,999 ; \u0026lt;- not executed *if* we jump over it lemme_outta_here: ret mov eax,0 ; sum added here mov edi,4 start: ; loop begins here add eax,10 ; add each time around the loop sub edi,1 ; loop increment cmp edi,0 ; loop test jg start ; continue loop if edi\u0026gt;0  ret Nhìn vào 2 ví dụ trên thì mọi chuyện không khác biệt, nếu bạn đã cố gắng hiểu những dòng comment. Tuy nhiên, khi debug assembly code thì thực sự là một cực hình (ít nhất thì mình có từng chạy code assembly khi học Computer Architecture - Kiến trúc máy tính), đặc biệt là phải soi rất kỹ lệnh cmp và lệnh jump các loại, đồng thời còn quan sát từng label nữa. Việc sử dụng câu lệnh goto sẽ khiến cho code chúng ta được tối ưu (không gian dòng lệnh, chức năng, tốc độ, et cetera) nhưng lại mang đến một hậu quả kinh khủng là cực hình khi debug (nhìn nhầm 1 dòng là không biết instructions pointer chạy đi đâu luôn). Để giải quyết vấn đề này thì một vài khái niệm đã xuất hiện giúp cho cuộc sống của các lập trình viên dễ dàng hơn bằng việc hỗ trợ thêm khái niệm scopes / control flows giúp code dễ đọc hơn khi phải thực hiện các thao tác như so sánh, lặp, hàm, et cetera. Hỗ trợ thêm nhiều từ khoá giúp con người dễ dàng làm quen hơn.\nint eax = 1; if (eax \u0026lt; 3){ eax = 999; } int eax = 1; int edi = 4; while (edi \u0026gt; 0){ eax = eax + 10; edi = edi - 1; } Bàn về procedural programming, cơ bản là mở rộng sự hỗ trợ của khái niệm subroutines từ structured programming, đồng thời kế thừa các khái niệm như scope / control flows để mở rộng thế giới của programming language, giúp việc viết một chương trình đơn giản hơn. Procedural language sẽ xoay quanh các khái niệm như record, module,procedure, procedure call. Thuở sơ khai thì procedural programming hỗ trợ cho phép các procedure thực hiện các thao tác thực tiếp lên vùng nhớ, giá trị của các thanh ghi / biến (record), đồng thời cũng hỗ trợ việc gom nhóm procedure liên quan tới nhau thành nhóm - module để dễ dàng quản lý, sử dụng ở nhiều nơi. Khi procedure call được gọi thì instruction pointer sẽ lập tức di chuyển đến nơi khai báo và thực hiện việc thao tác dựa trên dữ liệu được gọi (thường là địa chỉ của giá trị để thao tác trực tiếp). Sau khi procedural call kết thúc thì giá trị sẽ được cập nhật ở vị trí cũ và instruction pointer quay lại nơi được gọi và tiếp tục xử lý các instruction khác. Điều cần nói ở đây là procedural programming cần phải có sự hỗ trợ từ structured language. procedural có thể hiểu tương tự như function (hàm). Tuy nhiên hàm thì thay vì cập nhật trực tiếp giá trị ở ô nhớ thì lại trả về giá trị mới để chúng ta có thể tính toán bước tiếp theo mà không cần phải cập nhật giá trị ở ô nhớ cũ (thường là lưu lại để chuẩn bị tính toán tiếp). Sự khác biệt giữa procedural \u0026amp; function đa phần đến từ cách truyền giá trị vào và trả về giá trị.\nMột ngôn ngữ lập trình không nhất thiết chỉ hỗ trợ một paradigm, mà có thể nhiều paradigm. Một ví dụ điển hình hiện tại là phần lớn các ngôn như lập trình bậc cao đều hỗ trợ structured / procedural language (câu lệnh điều khiển và function/procedure). Ví dụ về pass by value \u0026amp; pass by reference là 2 trường hợp để phân biệt rõ nhất về sự khác nhau giữa function/procedure (Nếu không muốn thì cũng không sao cả vì sự khác biệt rất nhỏ). Để phân biệt rõ hơn về 2 khái niệm này thì cần phải tìm hiểu về các thanh ghi callee ($s) \u0026amp; caller ($t), tuy nhiên việc này cũng ít cần thiết nốt, vì đa phần các ngôn ngữ lập trình đã làm thay ta công việc này rồi. Hãy xem xét 2 ví dụ của C++ sau đây.\n#include \u0026lt;iostream\u0026gt; int mean(int a,int b){ return (a+b)/2; } void swap(int *a, int *b){ int t = *a; *a = *b; *b = t; } int main(){ int a = 100; int b = 21; cout \u0026lt;\u0026lt; mean(a,b) \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; swap(\u0026amp;a,\u0026amp;b); cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt; b; } Objet Oriented Programming \u0026amp; Functional Programming Functional Programming (lập trình hướng chức năng) là một loại phong cách lập trình, mục đích chủ yếu xoay quanh về việc các function (chức năng) được hoàn thành như thế nào. Chúng ta chỉ cần đưa vào input vào một chức năng thì sẽ có ngay lập tức output hợp lệ. {FP} thường xoay quanh việc áp dụng, tạo ra các function như thế nào. Những function này thường là một dãy các expression (biểu thức) để mapping (ánh xạ, biến đổi, et cetera) dữ liệu đầu vào thành dữ liệu đầu ra (input \u0026amp; output) mà tránh việc dữ liệu bị thay đổi (mutable state), side effects khiến cho code trở trên dễ hiểu, debug, test, et cetera. Javascript có hỗ trợ {FP}, tuy nhiên nên tránh nhầm lẫn giữa việc hỗ trợ {FP} và thuần {FP} (purely functional programming - được kế thừa dựa trên lambda calculus). {FP} xem function là first-class citizen, lưu ý rằng ở đây không mang ý nghĩa phân biệt thượng đẳng/hạ đẳng mà là nhằm mục đích để chỉ rằng tư tưởng của {fp} xoay quanh hàm - tức là function sẽ được fully supported. {FP} là một khái niệm rất mới, dần tiếp cận với các lập trình viên từ các framework của Javascript (Hook của React), nhưng những ngôn ngữ pure functional programming language thì lại khá là kén (haskell, lisp, et cetera). Sau đây sẽ là một vài ví dụ về {FP} ở trong Javascript.\nconst array = [5, 19, 16, 7, 5, 10, 17, 5, 2, 17, 15, 15, 17, 8, 15, 14, 8, 1, 11, 17] const array_less_than_15 = array.filter((element)=\u0026gt; element \u0026lt; 15) console.log(array_less_than_15) const array = [5, 19, 16, 7, 5, 10, 17, 5, 2, 17, 15, 15, 17, 8, 15, 14, 8, 1, 11, 17] const array_less_than_15 = [] for(let i = 0;i \u0026lt; array.length ; i++){ if (array[i]\u0026lt;15){ array_less_than_15.push(array[i]) } } Một điều lưu ý ở đây là chúng ta vẫn sử dụng method built-in của Array (filter) (vẫn có dính dáng tới OOP, vì Javascript hỗ trợ cả 2 paradigm này). Ngoại trừ {FP} thì chúng ta còn có {OOP}, nói về sự phổ biến của {OOP} thì không cần phải bàn cãi, vì hiện tại đây là một tượng đài không thể được vượt qua tại thời điểm hiện tại. Giống như {FP} luôn luôn xoay quanh function thì {OOP} lại đặt class \u0026amp; object là first-class citizens và mọi khái niệm xung quanh. Ưu thế của {OOP} nằm ở việc mô hình hoá mọi khái niệm ở trong chương trình trở thành những thứ quen thuộc, xung quanh đời sống khiến mọi chuyện trở nên dễ dàng tiếp cận với những người mới. Điểm khác biệt lớn nhất so với {FP} có lẽ là state - trạng thái - cũng có thể hiểu là dữ liệu. {FP} dành phần lớn thời gian để giúp chúng ta mapping - ánh xạ - từ input thành ouput thông qua các function. {OOP} thì lại quan tâm tới state và cách thay đổi state một cách internally (nội bộ). Có 4 đặc tính cơ bản mà {OOP} cung cấp cho chúng ta đó là : Abstraction, Encapsulation, Inheritance, and Polymorphism. Ngoại trừ 4 principles (nguyên lý) cơ bản này ra thì còn có nhiều Design Pattern. SOLID guidelines là một bộ gồm 5 nguyên tắc cơ bản để thiết kế một chương trình dựa trên {OOP}. Không dám bàn sâu về OOP vì còn non và xanh. Hãy cùng xem xét ví dụ để hiểu rõ hơn (ít nhất là tổng quan). Điều thú vị của Javascript là có thể cài đặt thêm prototype/method rất nhanh dựa trên Prototype-based implementation.\nconst array = [5, 19, 16, 7, 5, 10, 17, 5, 2, 17, 15, 15, 17, 8, 15, 14, 8, 1, 11, 17] // thay bằng arrow function sẽ không chạy nhé Array.prototype.less_than = function(number){ let array = new Array(); if (!number){ throw new Error(`Expected a number, but got ${typeof number}`) } for(let element of this){ if (element\u0026lt;number){ array.push(element) } } return array } let array_less_than_15 = array.less_than(15) console.log(array_less_than_15) Imperative / Declarative Programming Prototype ? How Javascript implement OOP  References \u0026amp; more resources  https://qz.com/852770/theres-a-limit-to-how-small-we-can-make-transistors-but-the-solution-is-photonic-chips/ https://en.wikipedia.org/wiki/Computer https://www.cs.uaf.edu/courses/cs301/2014-fall/notes/goto/ https://en.wikipedia.org/wiki/Procedural_programming https://www.educative.io/edpresso/pass-by-value-vs-pass-by-reference https://stackoverflow.com/questions/373419/whats-the-difference-between-passing-by-reference-vs-passing-by-value https://medium.com/javascript-scene/master-the-javascript-interview-what-is-functional-programming-7f218c68b3a0 https://en.wikipedia.org/wiki/Functional_programming https://en.wikipedia.org/wiki/Object-oriented_programming  ","date":"2021-05-04T08:21:25+07:00","image":"https://sonlhcsuit.github.io/p/programming-language-overview/cover_hu30291dafe49a91c64222be77f4152c73_77220_120x120_fill_box_smart1_2.png","permalink":"https://sonlhcsuit.github.io/p/programming-language-overview/","title":"Programming Language History Overview"},{"content":"Javascript là một ngôn ngữ lập trình duy nhất ở thời điểm hiện tại có thể chạy trên trình duyệt web ( WA - Web assembly có thể chạy trên browser, web assembly khiến cho binary code có thể chạy trên nền web). Duy nhất ở đây không phải là không thể tạo ra ngôn ngữ nào khác thay thế mà là không cần thiết vì Javascript đã quá trở nên phổ biến (ở đây tập trung nói về client-side Javascript). Javascript được thiết kế theo event-driven paradigm (Hướng sự kiện). Javascript không phải là ngôn ngữ duy nhất được thiết kế dựa trên paradigm này (Hầu hết các ngôn ngữ hỗ trợ xây dựng GUI đều hỗ trợ).\nEvent-driven Paradigm Giống như OOP được thiết kế dựa trên các Object \u0026amp; Class thì event-driven programming language được thiết kế dựa trên thành phần chủ yếu là Event \u0026amp; Listener. Đa phần các ngôn ngữ lập trình có thể xây dựng ứng dụng (application) đều hỗ trợ paradigm (Java, C, C++, et cetera). Lưu ý rằng là application ở đây không chỉ nói riêng về các GUI ở phía client mà còn cả ở phía server, vì server cũng phải luôn lắng nghe các request từ internet (dễ dàng mở rộng, tích hợp). Các ngôn ngữ lập trình đã hỗ trợ các event built-in (click, nhập liệu, di chuyển chuột, đọc file, xoá file, et cetera).\nEvent Emitters / Event Listeners Event có rất nhiều loại, tuy nhiên ta có thể khái quát lại thế giới của event-driven paradigm gồm : emitters \u0026amp; listeners. Một event được định nghĩa là một hành động nào đó xảy ra, khi các điều kiện phù hợp với một tiêu chuẩn nào đó , event đó sẽ emit ra một tín hiệu (signal) đến cho nhiều listener đang chờ đợi tín hiệu đó. Khi nhận được các tín hiệu thì các listener sẽ được thực thi. Thông thường listener là các hàm (callback) đã được khai báo sẵn, khi nhận được tín hiệu thì sẽ lập tức thực thi. Điều này cho phép ta sắp đặt các listener phù hợp với tương ứng với các event. Ví dụ như khi người dùng click nút Mua thì ta sẽ lập tức hiển thị lên thông tin về giao dịch, \u0026hellip;\nTa cũng có nhiều vấn đề phát sinh như sau:\n Event emit tín hiệu khi chương trình kết thúc thì như thế nào? Làm sao chúng ta biết được khi nào một Event emit tín hiệu? Lúc nhận được tín hiệu mà chúng ta đang thực hiện đoạn code khác thì sao? \u0026hellip;  Thông thường đối với vấn đề thứ nhất và thứ hai, ta sẽ chọn cách giải quyết là để chương trình luôn chạy, luôn luôn khiến các listener ỏ trong trạng thái sẵn sàng (mặc dù đã hết phần code ở phần main) tín hiệu từ Event. Vấn đề thứ ba ta có thể sử dụng đa luồng để giải quyết.\nLợi ích của event-driven paradigm gồm đơn giản và dễ mở rộng. Ví dụ về vấn đề mua hàng, ta có thể mở rộng bằng cách thêm các listener đảm nhận chức năng sign up/sign in vào mà không ảnh hưởng code của việc thực hiện giao dịch (tất nhiên vẫn phải đảm bảo logic: đã đăng nhập =\u0026gt; điền thông tin =\u0026gt; hiển thị thông tin giao dịch), giúp chúng ta tracing (theo dấu) được các hành vi của người dùng một cách tốt hơn.\nEvent Loops Tổng kết lại, một hành động listener sẽ được thực thi khi một sự kiện event nào đó được xảy ra (không nhất thiết từ phía người dùng). Để các event \u0026amp; listener chạy đúng đắn (event này xảy ra thì listener này được thực hiện, et cetera) thì chương trình cần phải chạy liên tục, luôn luôn chờ signal từ các event emitter (nguồn phát tín hiệu báo sự kiện hoàn thành ) để có thể thực hiện các listener. Event Loops là cơ chế giúp javascript có thể luôn chờ các tín hiệu phát ra, và điều phối thứ tự thực hiện các listener của nhiều event khác nhau. Event Loops giống một đứa con nít luôn hỏi mẹ \u0026ldquo;Mẹ ơi khi nào về?\u0026rdquo;, chỉ khác thứ Event Loops yêu cầu là tín hiệu của bất kỳ event. Javascript khi nhận được signal từ event emitter sẽ tìm kiếm đến các listener (một hàm callback) đang lắng nghe event và thực hiện (execute, call, invoke) nó.\n Event loops - client side   Event loops - nodejs \nĐiều đáng chú ý rằng javascript là một ngôn ngữ single thread (đơn luồng) dẫn tới việc javascript chỉ có 1 heap và 1 callstack (callback có thể sử dụng nhiều hàm chức năng khác nên callstack là cần thiết). Nếu nhiều event phát ra tín hiệu liên tiếp thì có cách giải quyết nào? Để giải quyết trường hợp này thì javascript hỗ trợ thêm khái niệm Event Queue, nhằm mục đích lưu trữ thứ tự các signal được emit từ các event khác nhau. Khi một listener được hoàn thành (thường là callstack trống), Event Queue sẽ lần lượt xử lý các listener tiếp theo.\nJavascript lúc bình thường sẽ chạy từng dòng một từ trên xuống đồng bộ (synchronous), tuy nhiên khi các event phát ra signal thì phải được xử lý thông qua Event Queue (Từng event một sẽ được xử lý).\nWebAPIs and Synchronous - Asynchronous Synchronous nghĩa là đồng bộ, nhằm chỉ việc code của chúng ta sẽ được thực thi theo thứ tự nhất định (từng dòng 1). Khi gặp các tao thác I/O thì code sẽ bị block (không chạy phần phía dưới) cho đến khi I/O hoàn thành (điển hình là alert \u0026amp; prompt). Cơ chế event queue của javascript cũng được tính vào synchronous và asynchronous.\nXem xét ví dụ sau đây.\nlet btn = document.querySelector(\u0026#34;#btn\u0026#34;) btn.addEventListener(\u0026#34;click\u0026#34;,()=\u0026gt;{ console.log(\u0026#34;clicked\u0026#34;) }) btn.click() // thực hiện thao tác click vào nút, thay vì đợi người dùng click console.log(\u0026#34;he?\u0026#34;) // clicked // he // listener được execute trước! Asynchronous nghĩa là bất đồng bộ, hằm chỉ việc code của chúng ta sẽ không được thực thi theo thứ tự đã viết. Xem xét ví dụ sau đây.\nlet btn = document.querySelector(\u0026#34;#btn\u0026#34;) btn.addEventListener(\u0026#34;click\u0026#34;,()=\u0026gt;{ setTimeout(()=\u0026gt;{ console.log(\u0026#34;clicked\u0026#34;) },0) }) btn.addEventListener(\u0026#34;click\u0026#34;,()=\u0026gt;{ console.log(\u0026#34;clicked 2\u0026#34;) }) btn.click() // thực hiện thao tác click vào nút, thay vì đợi người dùng click console.log(\u0026#34;he?\u0026#34;) // clicked 2 // he // clicked // listener được execute sau! Lí giải tại sao ví dụ thứ 2 lại có kết quả như vậy là bởi vì có sự can thiệp của Web API. WebAPI hỗ trợ chúng ta nhiều thứ như ajax, timers, file reader, et cetera. Về mặt bản chất thì Web API cũng hoạt động dựa trên event queue, tuy nhiên hơi khác một tí là: Nếu sử dụng Web APIs thì thứ tự ưu tiên của event được emit từ Web APIs sẽ \u0026ldquo;kém hơn\u0026rdquo; các event, nghĩa là Event sẽ bị hoãn cho tới khi callstack trống (code của chương trình chính được chạy hoàn toàn) thì mới được đưa vào Event Queue và bắt đầu xử lý theo quy tắc của Event Queue( lấy từng Event ra -\u0026gt; tạo callstack mới -\u0026gt; execute listener).\nHãy thử đoạn code trên với vòng lặp for dùng để blocking khoảng 2s\nlet btn = document.querySelector(\u0026#34;#btn\u0026#34;) btn.addEventListener(\u0026#34;click\u0026#34;,()=\u0026gt;{ setTimeout(()=\u0026gt;{ console.log(\u0026#34;clicked\u0026#34;) },0) }) btn.addEventListener(\u0026#34;click\u0026#34;,()=\u0026gt;{ console.log(\u0026#34;clicked 2\u0026#34;) }) btn.click() // thực hiện thao tác click vào nút, thay vì đợi người dùng click for(let i = 0;i\u0026lt;3000000000;i++){ // block 3s } console.log(\u0026#34;he?\u0026#34;) // clicked 2 // Phải đợi khoảng 3s, mặc dù hàm setTimeout có thời gian đợi là 0s! // he // clicked Những tác vụ có sử dụng Web APIs được gọi là những tác vụ asynchronous (điều ngược lại không đúng). Các tác vụ asynchronous (thường là function) sẽ có độ ưu tiên kém (chỉ được thêm vào event queue khi callstack trống lần đầu tiên - Hoàn thành hết code synchronous). Sau đó thì cũng sẽ được xử lý dưới cơ chế event queue \u0026amp; event loops. Sau khi đã qua hoàn thành code javascript synchronous thì mọi thứ sẽ được nhường về cho Event Loops và những thứ liên quan. Nên chú ý một chút về các listener, các listener phải được hoàn thành toàn bộ (callstack rỗng) thì event queue mới có thể đưa listener kế tiếp vào hoàn thành, vậy nên nếu listener trước chưa được hoàn thành thì phải đợi chờ đến khi được hoàn thành. Khi một listener đang chạy (tốn thời gian rất lâu) thì các interaction khác sẽ không chạy (ví dụ như scroll, click,..) cho nên đừng có làm gì quá rắc rối trong listener - Ví dụ như animation, đệ quy không có điểm dừng, tính số fibnacci ,\u0026hellip; - cơ chế này có tên là \u0026ldquo;Run to completion\u0026rdquo;.\nĐây cũng chính là sức mạnh của Javascript khi so sánh với các ngôn ngữ khác!\nTổng kết lại, event loops sẽ xem xét xem thử có bất kỳ event nào phát ra tín hiệu không? Nếu có thì sẽ thêm vào event queue. Nếu callstack trống, event queue sẽ xử lý từng listener tương ứng với signal được event phát ra. WebAPIs cung cấp cho chúng ta các công cụ tiện lợi(timers, fetch, file reader, et cetera) và hoạt động dựa vào event loops! Tuy nhiên WebAPIs bao gồm nhiều hành động asynchronous, kỹ năng xử lý hành động asynchronous rất quan trọng khi làm việc với Javascript.\nCó một câu hỏi hay khi phỏng vấn như thế này:\u0026ldquo;Javascript là ngôn ngữ lập trình đơn luồng hay là đa luồng? Tại sao Javascript lại là đơn luồng/ đa luồng? Nếu Javascript là đơn luồng thì tại sao tại thực hiện được nhiều tác vụ cùng một lúc (ví dụ như fetch nhiều request cùng lúc)?\u0026rdquo;. Điều đâu tiên, javascript là ngôn ngữ đơn luồng bởi vì javascript chỉ có duy nhất một callstack và heap. Javascript không thực sự xử lý nhiều request cùng 1 lúc, chỉ là cơ chế Event loops của Javascript khiến cho Javascript trông như có thể xử lý nhiều hành động cùng 1 lúc (nhiều event có thể xảy ra cùng 1 lúc nhưng các listeners thì phải được giải quyết theo thứ tự). Nói về hàm fetch, Javascript có thể sử dụng hàm fetch để lấy thông tin nhiều request cùng lúc (Promise.all), tuy nhiên, fetch là WebAPIs - nghĩa là thứ thực hiện việc gọi nhiều request cùng lúc là Browser, runtime engine chứ không phải Javascript. Khi tất cả các request được hoàn thành (nhận được response) thì WebAPIs sẽ đẩy Event vào Event Queue, lúc này các listeners (hay là các đoạn code handle promise) sẽ được thực hiện lần lượt.\n References \u0026amp; more resources  https://en.wikipedia.org/wiki/Event-driven_programming https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop https://www.youtube.com/watch?v=8aGhZQkoFbQ https://medium.com/@giangcoffee/event-loop-l%C3%A0-g%C3%AC-v%C3%A0-ho%E1%BA%A1t-%C4%91%E1%BB%99ng-th%E1%BA%BF-n%C3%A0o-d52caa908090  P/S: Các đoạn code ở trên được mình chạy ở trên engine V8 của Chrome thông qua trình duyệt Brave. Có thể tuỳ thuộc vào các engine có một cách thực thi Javascript khác nhau nên có gì sai sót xin email cho mình để mình cập nhật. Xin cảm ơn!\n","date":"2021-04-23T09:02:11+07:00","image":"https://sonlhcsuit.github.io/p/event-loops/cover_hu61a978d01b41be1072a21c5a2a854809_64775_120x120_fill_box_smart1_2.png","permalink":"https://sonlhcsuit.github.io/p/event-loops/","title":"Event Loops"},{"content":"Function Function là một khái niệm quan trọng trong nhiều ngôn ngữ lập trình bậc cao. Theo định nghĩa từ toán học thì function là những expression, rules,laws được sử dụng để định nghĩa những relation giữa nhiều dependant variables (biến độc lập). Nói một cách khó hiểu hơn, là một mapping (ánh xạ) từ một giá trị ở miền giá trị này sang một giá trị khác ở miền giá trị khác.\n Định nghĩa về function theo toán học \nKhi làm việc với các ngôn ngữ lập trình thì chúng ta lại sử dụng hàm khác đi một chút. Function là một \u0026ldquo;cỗ máy\u0026rdquo; nhận vào những input và đưa ra cho chúng ta output. Khi viết một hàm, chúng ta đang thiết kế cách mà \u0026ldquo;cỗ máy\u0026rdquo; hoạt động, cách chuyển đổi từ input sang output, chúng ta có thể sử dụng bản thiết kế này chúng ở mọi nơi bằng cách invoke,call (gọi hàm - sẽ có sự khác biệt phía bên dưới).\n Định nghĩa về function nhưng bớt khó hiểu hơn \nCreate function Có một vài điều cần lưu ý khi sử dụng function như sau: - Phải khai báo function trước khi sử dụng - function không chạy tại thời điểm được khai báo mà chỉ chạy khi được invoke/call Ngoại trừ những điều trên thì còn một vài thứ linh tinh nữa. Trong Javascript thì chúng ta có thể khai báo function bằng 2 cách - sử dụng function definition hoặc function expression. Javascript xem function như là một đối tượng, nên function có thể là output của một function khác.\n// Sử dụng function definition với từ khoá function function functionName(parameters_comes_here){ // function_body here  // remember to return something } // Sử dụng function expression // const / let/ var đều có thể const myFunctionName = (parameters_comes_here)=\u0026gt;{ // function_body here  // remember to return something } Parameter / Argument Khi khai báo hàm thì ta cần phải chú ý function name (quy tắc đặt tên giống tên biến) và function parameter. Parameter nghĩa là tham số đầu vào - một cách gọi khác của input. Parameter là biến dùng để lưu giá trị nhận được khi function được invoke/call. Function sẽ yêu cầu một số lượng nhất định các parameter khi khai báo, đồng thời cũng phải đúng số lượng các argument truyền vào khi hàm được invoke/call và đúng thứ tự được khai báo . Tuy nhiên Javascript không bắt buộc điều này, số lượng các parameter và argument có thể khác nhau. Điều này dẫn tới một số vấn nhỏ.\nĐối với việc số lượng các parameter và argument bằng nhau.\n// Khai báo hàm cube với 3 parameter là a, b, c function cube(a,b,c){ return a**3 + b**3 + c**3 } // Invoke/call hàm cube với 3 argument tương ứng là 2, 3, 4 let result = cube(2,3,4) console.log(result) // 99 Đối với việc số lượng các parameter và argument không bằng nhau.\n// Khai báo hàm cube với 3 parameter là a, b, c function cube(a,b,c){ return a**3 + b**3 + c**3 } // Invoke/call hàm cube với 2 argument tương ứng là 2, 3 let result = cube(2,3) console.log(result) // NaN // Lý do bởi vì giá trị của c không được truyền vào =\u0026gt; các biến // có giá trị mặc định là undefined nếu không có quá trình initialization  // Invoke/call hàm cube với 5 argument tương ứng là 2, 3, 4, 5, 6 let result = cube(2,3,4,5,6) console.log(result) // 99 // Thiếu mất giá trị 5, 6. Như vậy liệu rằng hàm // của chúng có đang ở dạng tổng quát (general)? Thông qua 2 ví dụ trên về sự khác biệt số lượng parameter/argument, ta có thể có vài rắc rối cần phải giải quyết. Một trong cách giải quyết đơn giản nhất là sử dụng duy nhất 1 parameter với kiểu dữ liệu là array. Ngoại trừ cách đó thì chúng ta còn có thể sử dụng reserved word là arguments - giúp chúng ta biến tất cả các arguments thành đối tượng array-like (gần như mảng nhưng không phải mảng).\n// Sử dụng mảng function cube(arrayOfNumbers){ let n = arrayOfNumbers.length; let sum = 0; for(let i = 0;i \u0026lt; n ; i++ ){ sum+= arrayOfNumbers[i] } return n } // sử dụng hàm let result = cube([2,3,4]) console.log(result) // Sử dụng từ khoá arguments. Khi sử dụng từ khoá thì chúng // ta có thể không khai báo parameter. Nếu khai báo thì cũng // vẫn có thể sử dụng như một biến function cube(a,b,c){ let n = arguments.length; // tuy nhiên chúng ta vẫn có thể truy cập tới arguments[0]  // arguments[1], arguments[2] bằng a, b, c theo thứ tự  let sum = 0; for(let i = 0;i \u0026lt; n ; i++ ){ sum+= arguments[i] } return n } let result = cube(2,3,4,5,6,7,8,9,10) console.log(result) Lexical Environment / Execution Context / Execution Stack Khi khai báo function ta sử dụng cú pháp {} để tạo scope dánh cho function body. Scope này còn có tên là Lexical Environment (Lexical).Khi khai báo identifiers thi identifier sẽ bind với lexical/scope đó (mặc định). Khi một hàm call/invoke (scope thường sẽ được gọi) Lexical thường chứa thông tin về về các identifier , đồng thời cũng chứa thông tin về parent lexical khi tìm kiếm identifier không tồn tại trong lexical hiện tại. Khi một hàm được invoke/call thì ngay lập tức Javascrit engine tạo ra một execution context và một lexical cho việc lưu trữ các biến (giả sử nếu cùng tên trong hàm). Execution context đặt chúng lên đầu của execution stack, đồng thời lưu vào lexical vị trí của statement pointer hiện tại, đồng thời cập nhật giá trị statement pointer thành nơi bắt đầu hàm vừa được invoke/call. Execution context lớn nhất là global.\nJavascript engine sẽ thực hiện lần lượt từ trên xuống dưới (top to bottom of stack). Khi function hoàn thành, execution context của function đó sẽ được pop ra khỏi execution context,và statement pointer sẽ quay về vị trí đã gọi function vừa hoàn thành, tiếp tục công việc thực thi từng dùng. Execution stack đảm bảo được rằng các được gọi sau (trong các hàm bất kỳ) hoàn thành trước để đảm bảo tính đúng đắn của chương trình.\nQuy tắc tìm kiếm các identifier dọc theo mối quan hệ cha - con của lexical được gọi là scope chain. Một điều cần chú ý đối với function là, execution context mặc định nó sẽ được bind với scope được khai báo. Tức là outer scope (outer execution context) của function khi call/invoke là nơi khai báo (chứ không phải là nơi call/invoke).\nfunction A(){ let v = \u0026#39;from A\u0026#39; console.log(v) } function B(){ let v = \u0026#39;from B\u0026#39; A() } let v = \u0026#39;from Global\u0026#39; B() // from A // Xoá đi dòng thứ 2 thì kết quả là // from Global Xem xét ví dụ sau thì kết quả đơn giản là from A. Tuy nhiên nếu xoá đi dòng let v = 'from A' thì kết quả lại là from Global. Lý do bởi vì A được khai báo ở global chứ không phải là B. Mặc dù được gọi ở lexical B nhưng A lại không thể tìm kiếm các identifiers ở lexical B. Vậy có cách nào để bind lexical ở nơi nó được gọi hay không? Theo mình biết thì hiện tại là chưa ngoại trừ việc bạn viết lại một runtime engine theo ý muốn.\nHoisting Hoisting (Xem thêm ở Variable), tuy nhiên có một điều bổ sung nữa là. Giai đoạn hoisting chỉ xảy ra khi một execution context được tạo ra, và việc khai báo đè cũng chỉ ảnh hưởng trong execution context đó.\nfunction f(){ let h = 12; let a = 22 function g(){ // Hoisting function =\u0026gt; bị ghi đè  console.log(h) // let h = 10  function h(a){ console.log(a) // debugger;  console.log(\u0026#39;From h w/love\u0026#39;) } h() console.log(\u0026#39;From g w/love\u0026#39;) } console.log(h) g() console.log(h) console.log(\u0026#39;From f w/love\u0026#39;) } f() Một vài sự chú ý nhỏ đây là trong lexical của hàm f thì identifier h đã được khai báo bằng từ khoá let, vậy tại sao khi in h ra console lại bị thay đổi? Khi sử dụng từ khoá function thì hoisting xảy ra, thay thế identifier h của hàm f, thay thế bằng h của hàm g. Vì lexical hiện tại là hàm g Javascript engine sẽ chọn identifier ở gần lexical hiện tại nhất (là idetitier h của hàm g chứ không phải f).\nNgoài ra thì ở dòng đầu tiên của hàm h, kết quả chúng ta nhận được undefined chứ không phải 12. Lí do là các parameter cũng được khai báo bằng từ khoá var giống như biến (tức là cũng xảy ra hoisting). Sau đó mới được gán giá trị được truyền vào lúc được invoke/call. Vậy nên giá trị của a là undefined (vì mới được khởi tạo) và đồng thơi cũng được copy từ argument sang - tuy nhiên hàm h lại gọi với không có argument nào nên các parameter vẫn giữ giá trị là undefined.\nCallback / Higher Order Function / Closure Trong Javascrip, function được xem là một Object (một kiểu dữ liệu).Điều này đồng nghĩa với ta có thể truyền một function như là argument khi invoke/call một function khác, hay nó cũng có thể là một gì đó được trả về như là kết quả của việc invoke/call một function.\nNhững function được truyền như argument khi invoke/call một function khác thì có tên là callback. Những function không thể được truyền như callback thì được gọi là first-class function hay là higher order function.\nClosure là khả năng ghi nhớ, kết hợp lexical giữa các hàm được trả về/ callback / listener. Thay vì tìm kiếm identifier ở global lexical thì function y sẽ tìm kiếm ở lexical mà được khai báo trước (tức là lexical của function x) rồi mới tới lexical hiện tại (nơi mà function được invoke/call)\nfunction x(){ let y = \u0026#39;hihihi\u0026#39; let u = \u0026#39;huhuhu\u0026#39; function z(){ console.log(y) console.log(u) } return z } let u = \u0026#39;?\u0026#39; let y = x() y() console.log(u) // hihih Ngoài ra, có một ví dụ cổ điển việc closure/lexical ở MDN, mình trích dẫn nó ở đây. Hãy tự suy nghĩ xem cách giải quyết và lý giải rằng lại sao nó lại như thế nhé (cần biết về lexical/scope chain/ closure)\n\u0026lt;p id=\u0026#34;help\u0026#34;\u0026gt;Helpful notes will appear here\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;E-mail: \u0026lt;input type=\u0026#34;text\u0026#34; id=\u0026#34;email\u0026#34; name=\u0026#34;email\u0026#34;\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;Name: \u0026lt;input type=\u0026#34;text\u0026#34; id=\u0026#34;name\u0026#34; name=\u0026#34;name\u0026#34;\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;Age: \u0026lt;input type=\u0026#34;text\u0026#34; id=\u0026#34;age\u0026#34; name=\u0026#34;age\u0026#34;\u0026gt;\u0026lt;/p\u0026gt; function showHelp(help) { document.getElementById(\u0026#39;help\u0026#39;).textContent = help; } function setupHelp() { var helpText = [ {\u0026#39;id\u0026#39;: \u0026#39;email\u0026#39;, \u0026#39;help\u0026#39;: \u0026#39;Your e-mail address\u0026#39;}, {\u0026#39;id\u0026#39;: \u0026#39;name\u0026#39;, \u0026#39;help\u0026#39;: \u0026#39;Your full name\u0026#39;}, {\u0026#39;id\u0026#39;: \u0026#39;age\u0026#39;, \u0026#39;help\u0026#39;: \u0026#39;Your age (you must be over 16)\u0026#39;} ]; for (var i = 0; i \u0026lt; helpText.length; i++) { var item = helpText[i]; document.getElementById(item.id).onfocus = function() { showHelp(item.help); } } } setupHelp(); Call / Invoke Invoke là việc gọi trực tiếp một hàm bằng việc dùng tên f(). Call là sử dụng HOF để invoke hàm đó bằng cách gián tiếp\nfunction g(callback){ console.log(\u0026#39;From g w/love\u0026#39;) cb() } function h(){ console.log(\u0026#39;From h w/love\u0026#39;) } g(h) // invoke g, but g call h instead us  References \u0026amp; more resources  https://www.britannica.com/science/function-mathematics https://stackoverflow.com/questions/50884893/calling-vs-invoking-a-function https://www.w3schools.com/js/js_function_definition.asp https://stackoverflow.com/questions/12599965/lexical-environment-and-function-scope https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures  P/S: Có thể tuỳ thuộc vào các engine có một cách thực thi Javascript khác nhau nên có gì sai sót xin email cho mình để mình cập nhật. Xin cảm ơn!\n","date":"2021-04-18T00:17:35+07:00","image":"https://sonlhcsuit.github.io/p/function/cover_hu062f41afdd6355ed08a984ff4566dc16_79012_120x120_fill_box_smart1_2.png","permalink":"https://sonlhcsuit.github.io/p/function/","title":"Functions"},{"content":"Variable Biến là một khái niệm rất quan trọng trong nhiều ngôn ngữ lập trình, được sử dụng để lưu trữ các giá trị. Chúng ta có thể gán một giá trị cho một biến, khi nào cần giá trị cho việc tính toán (số, chuỗi, etc.) thì sử dụng tên biến thay vì giá trị, các interpreter, compiler truy xuất đến giá trị đã được gán vào biến, thay thế vào biểu thức và thực hiện việc tính toán. Con người dễ tiếp thu ngôn ngữ hơn là những giá trị hoặc con số, biến là một ánh xạ đơn giản, một từ sinh ra giá trị. Tên của biến phải là độc nhất theo những quy tắc đặt tên của các ngôn ngữ lập trình, một biến chỉ lưu trữ một giá trị tại 1 thời điểm nhất định.\nThoát khỏi việc ghi nhớ các giá trị bằng cách sử dụng biến, các lập trình viên lại có thêm vài vấn đề như sau: Đặt tên biến như thế nào để ngắn gọn, dễ nhớ? Muốn nhiều biến có cùng tên được không? etc. Nhằm giải quyết vấn đề về cách đặt tên biến, các ngôn ngữ lập trình đã hỗ trợ thêm những khái niệm lexical, scope,\u0026hellip;\nVariable naming Nói về việc đặt tên biến thì có nhiều quy tắc\n Tối thiểu:  Tên của một biến phải độc nhất trong một phạm vi nhất định Bao gồm các ký tự trong bảng chữ cái (cả thường và hoa), số, ký tự đặc biệt cho phép tuỳ theo mỗi ngôn ngữ lập trình (JS thì chỉ cho phép 2 ký tự là \u0026ldquo;_\u0026rdquo; và \u0026ldquo;$\u0026quot;) Không được trùng với các reserved word (keyword) Không được bắt đầu bằng số   Nên có:  Ít mang động từ Ngắn ngọn, súc tích, có nghĩa Sử dụng cách nối (như kebab case, snake case, camel case,etc.) khi có nhiều hơn 2 từ \u0026hellip;    Và quan trọng hơn hết là phải tuân thủ cú pháp để khai báo biến của từng ngôn ngữ lập trình!\n// ở trong javascript, chúng ta có 3 cách khai báo biến // bằng viêc sử dụng 3 reserved word như var, let, const var revenues; let costs; const profits; Vốn từ vựng nhiều là một lợi thế khi đặt tên biến, tuy nhiên chúng ta không đặt tên biến khác nhau hoàn toàn. Nếu đặt tên biến khác nhau hoàn toàn thì sẽ có rất nhiều biến, việc nhớ chúng sẽ rất tốn thời gian. Thay vì đó, các ngôn ngữ lập trình hỗ trợ các khái niệm idetifier, scope, lexical,etc. để giúp chúng ta tiết kiệm thời gian, công sức.\nIdentifier \u0026amp; access scope Biến là một identifier, tức là định danh (identifier còn có thể các function, class,etc). Chúng ta có thể khởi tạo (tạo ra) nhiều biến có cùng tên, lưu trữ các giá trị khác nhau ở các scope khác nhau. Trình duyệt sẽ dựa vào scope, xác định identifier và giá trị của chúng phù hợp. Các identifier khi được khởi tạo luôn được gắn chặt với scope nơi mà chúng được khởi tạo. Chúng ta chỉ có thể truy cập tới các identifier ở các outer scope, không đối với inner scope. Scope có phạm vi truy cập lớn nhất Global Scope.\nSự khác biệt giữa let \u0026amp; var\nlet revenues = 100000; let costs = 12345 if (revenue \u0026gt; 0 ){ let profits = revenues - costs } console.log(profits) // ReferenceError: profits is not defined // Hàm console ở global scope truy cập tới biến profits, // tuy nhiên biến profits được khởi tạo ở scope của if (inner scope), // nên việc truy cập thất bại. Tuy nhiên việc truy cập // revenues \u0026amp; costs đều thành công khi ở trong scope của if vì // đối vời scope của if thì global là outer scope Khi thực hiện việc tìm kiếm các identifier thì ta sẽ tuân theo quy tắc từ trong ra ngoài. Javascript sẽ xét ở scope hiện tại, sau đó chuyện tới outer scope, xét tiếp, tiếp tục chuyển tới outer scope,\u0026hellip; cho tới khi gặp được identifier hợp lệ hoặc tới global scope mà không tìm được thì sẽ báo lỗi (Cách tìm kiếm identifier được gọi là scopes chain). Đối với từ khoá let thì quy tắc scopes chain đúng hoàn toàn, và nhiều ngôn ngữ khác cũng vậy. Tuy nhiên điều này không hoàn toàn đúng với var.\nif (true){ var z = 100 } console.log(z) // 100 // Điều này chứng mình rằng khi khai báo var, quy tắc scope chain // không còn chính xác nữa var đặc biệt hơn với let ở chỗ nó không tuân theo quy tắc chung. Chúng ta có thể kết luận rằng, khi khai báo identifier với từ khoá var sẽ có scope là global không? Tất nhiên là không!\nfunction initialVariable() { var z = \u0026#39;this is z\u0026#39; console.log(z) } initialVariable() console.log(z) // this is z // ReferenceError: z is not defined Vậy nên ta không thể kết luận rằng khai báo identifier với từ khoá var sẽ có scope là global. Vậy thì lí do tại sao ví dụ ở trên lại bị sai nhỉ? Câu trả lời là đối với scope của hàm thì có một chút khác biệt, có tên là lexical. Khi khai báo identifier bằng var, thay vì bind vào scope, thì identifier được bind vào lexical. Ngoại trừ điều đó ra thì var còn có khả năng redeclarion (tái khai báo) mà không gặp lỗi. (làm với let thì sẽ gặp lỗi SyntaxError: Identifier _ has already been declared)\nvar z =\u0026#39;this is z at first\u0026#39; console.log(z) function initialVariable() { var z = \u0026#39;this is z\u0026#39; console.log(z) var z = \u0026#39;this is z but 4th\u0026#39; // redeclaration  console.log(z) } initialVariable() console.log(z) // this is z at first // this is z // this is z but 4th // this is z at first Xét thêm trường hợp này\nvar z= 1000 function f() { var fs = [] for (var i = 0; i \u0026lt; 5; i++) { fs.push(function () { var z = i console.log(z) }) } fs[3]() } f() console.log(z) // 5 // i được khai báo ở lexical f, khi thực hiện vòng lặp với post operator là i++ thì // đang thay đổi giá trị của biến i ở lexical f. Ngoại trừ việc bind khác một chút var vẫn tuân theo quy tắc của scope chain. Có nhiều bạn tưởng rằng var sẽ tạo một property ở global object (cụ thể window ) - chưa hoàn toàn đúng, chỉ khi nào bạn khai báo bằng var ở global scope thì mới tạo property, còn lại thì không.\nfunction f() { var z = \u0026#39;111\u0026#39; console.log(z) console.log(window.z) } f() const Điều khiến identifier đặc biệt là không cho phép direct assignment. Assignment là một toán tử cho phép cập nhật giá trị đã được lưu trữ của identifier.\nconst z = 100; z = \u0026#39;??\u0026#39; // TypeError: Assignment to constant variable. Tuy nhiên ,việc thay đổi nội tại bên trong, hoặc thay đổi thông qua trung gian vẫn có thể.(Đối với references data type)\nconst z = [] console.log(z) z.push(1,2,3,4) console.log(z) // [] // (4) [1, 2, 3, 4] const z = {} z.name = \u0026#39;z\u0026#39; console.log(z) // {name: \u0026#34;z\u0026#34;} Hoisting \u0026amp; Tempotary Dead Zone Một identifier được khỏi tạo thông qua 1 hoặc 2 giai đoạn : declaration (defination) và initialization. Giai đoạn 2 có thể có hoặc không. declaration mang ý nghĩa cấp vùng nhớ dùng để lưu giá trị và bind identifier với giá trị có sẵn ở vùng nhớ(C++), initialization mang ý nghĩa khởi tạo cho giá trị ban đầu là bao nhiêu. Nếu không có initialization thì giá trị mạc định là undefined\nlet z; // declaration let z = 100; // declaration + initialization Hãy xem xét các ví dụ sau:\nconsole.log(z) let z = 10; // ReferenceError: Cannot access \u0026#39;z\u0026#39; before initialization // Chúng ta đã sử dụng biến z trước khi nó được khai báo, đây được gọi là tdz console.log(z) var z = 10; // undefined // Nếu thay let bằng var thì ta lại nhận được giá trị. Đây là ví dụ cho việc hoisting Tempotary Dead Zone là khái niệm dùng để nói về việc sử dụng một identifier trước khi được tạo ra.Hoisting áp dụng đối với identifier được khai báo bằng từ khoá var và function. Hoisting chỉ hiệu quả trong một lexical. Hoisting nghĩa là Javascript sẽ đem tất cả các biến phù hợp ( khai báo bằng var và function), thực hiện việc declaration trước, khi đến dòng thực sự khai báo, chỉ phải thực hiện assignment mà thôi.\nTDZ không phải ám chỉ thứ tự khai báo các biến và sử dụng, mà thường dùng để nói về thứ tự thực thi (Execution Order). Miễn là tại thời điểm thực thi các biến đã được khởi là là ổn. TDZ thường hay đề cập đối với let hơn là var (var sẽ Javascript áp dụng hoisting nên chuyện chưa được khởi tạo không xảy ra - chỉ có vấn đề là giá trị là undefined mà thôi). Để khắc phục tình trạng một biến gặp trường hợp tdz thì nên cân nhắc đem tất cả các biến lên khai báo ở đầu scope/lexical\nif(true){ console.log(z); console.log(x); var z = \u0026#39;this is z\u0026#39;; let x = \u0026#39;this is x\u0026#39;; } // undefined // ReferenceError: Cannot access \u0026#39;x\u0026#39; before initialization // Đây là ví dụ về thực thi if (true){ //  function f(){ console.log(z) } let z = \u0026#39;this is z\u0026#39; } f() // // this is z // this is z - khi khai hàm bằng function =\u0026gt; giống như var // bind thẳng lexical chứ không phải scope - arrow function // khắc phục được điểm này Khi bạn sử dụng các từ khoá để khởi tạo các identifier, thì các identifier được bind vào scope/lexical tuỳ thuộc vào nơi khai báo. Nhưng nếu bạn không khai báo biến mà trực tiếp assignment thì mặc định Javascript sẽ làm tự động tạo cho bạn 1 biến ở global scope (Nếu chưa tồn tại ở scope chain dẫn ra global scope)\nx = \u0026#39;this is x\u0026#39;; function f() { function g(){ z = \u0026#39;this is z lexical of g\u0026#39; } g() } f(); console.log(globalThis) console.log(x, z); // this is x this is z lexical of g  References \u0026amp; more resources  https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/var https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/const https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference   P/S: Các đoạn code ở trên được mình chạy ở trên engine V8 của Chrome thông qua trình duyệt Brave. Có thể tuỳ thuộc vào các engine có một cách thực thi Javascript khác nhau nên có gì sai sót xin email cho mình để mình cập nhật. Xin cảm ơn!\n","date":"2021-04-12T19:01:17+07:00","image":"https://sonlhcsuit.github.io/p/variable/cover_hu827c0ed010dfc5634e95366bcb9fa524_10906_120x120_fill_box_smart1_2.png","permalink":"https://sonlhcsuit.github.io/p/variable/","title":"Variable"},{"content":"Khi xử lý với Event thông qua DOM ở trong Javascript, cần phải hiểu một chút kỹ càng về cách các event hoạt động. Mỗi khi một event được trigger, bắt đầu thực thi listener thì cùng lúc cũng có nhiều listener được kích hoạt cùng lúc. Có các cơ chế để trình duyệt thực hiện những listener theo một thứ tự xác định. Các cơ chế cơ bản đó là bubble \u0026amp; capturing.\nXem xét các ví dụ sau đây về độ sâu (depth) của cây DOM thông qua đoạn HTML\n\u0026lt;div class=\u0026#34;box box-1\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;box box-2\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;box box-3\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; *{ margin: 0; padding: 0; box-sizing: border-box; } .box { display: block; margin:20px; } .box.box-1{ width: 40vh; height: 40vh; border: solid 1px red; } .box.box-2{ width: 30vh; height: 30vh; border: solid 1px black; } .box.box-3{ width: 20vh; height: 20vh; border: solid 1px blue; } Khi hiển thị trên trình duyệt thì kết quả sẽ gồm 3 hình vuông lớn nhỏ theo kích thước và thứ tự sau:  Hiển thị đoạn của code ở phía trên \nBox 3 - nằm trong Box 2 - nằm trong Box 1. Sử dụng một chút logic thì ta cũng có thể nhận thấy rằng khi người dùng click vào Box 3 thì cũng là người dùng click vào Box 2 và Box 1 (bởi vì Box 2 và Box 1 có kích thước lớn hơn và Box 3 nằm ở bên trong)\nNếu chúng ta thêm các listener vào event click, thì khi event được trigger ở Box 3 thì các listener ở Box 2, Box 1 cũng được trigger theo. Và kết quả là cả 3 listener đều được thực thi. Điều này đúng với logic căn bản, tuy nhiên nếu các listener này xung đột lẫn nhau (ví dụ ẩn/hiện các component thì không hợp lý chút nào ). Cần nắm rõ cơ chế lan truyền - propagation - các event.\nCó 2 cơ chế lan truyền chính của các trình duyệt hiện tại là bubble \u0026amp; capture. Nhiều trình duyệt đã chuyển sang cơ chế mặc định là bubbles - từ \u0026ldquo;dưới lên \u0026ldquo;trên\u0026rdquo;. Còn cơ chế capture sẽ ngược lại, từ \u0026ldquo;trên\u0026rdquo; xuống \u0026ldquo;dưới\u0026rdquo;.\nĐối với cơ chế capture: trình duyệt sẽ bắt đầu từ gốc của cây DOM, tìm dần xuống tới element được kích hoạt (Box 3). Để tới được Box 3 thì phải trải qua các Node sau : html -\u0026gt; body -\u0026gt; box 1 -\u0026gt; box 2 -\u0026gt; box 3. Như vậy theo cách duyệt cây này thì các listener sẽ được trigger theo thứ tự trên (nếu đã được định nghĩa). Còn cơ chế bubble sẽ thực hiện ngược lại, từ node lá duyệt ngược lên gốc: box 3 -\u0026gt; box 2 -\u0026gt; box 1 -\u0026gt; body -\u0026gt; html. Và các listener sẽ được kích hoạt với thứ tự trên.\nMặc định các trình duyệt hiện đại đều sử dụng cơ chế bubble. Tuy nhiên ta có thể chỉ định sử dụng cơ chết capture bằng cách sau.\ndocument.querySelectorAll(\u0026#39;.box\u0026#39;).forEach(element =\u0026gt; { element.addEventListener(\u0026#34;click\u0026#34;, function (){ console.log(this.classList.value) }) }) // bubbles  Cơ chế bubble \ndocument.querySelectorAll(\u0026#39;.box\u0026#39;).forEach(element =\u0026gt; { element.addEventListener(\u0026#34;click\u0026#34;, function() { console.log(this.classList.value) }, { capture: true }) }) // capture  Cơ chế capture \nTuy nhiên đôi khi chúng ta cần ngăn chặn sự lan truyền (tức là chỉ kích hoạt những listener phía trước để đảm bảo đúng dữ kiện ) bằng cách sử dụng phương thức Event.stopPropagation()\ndocument.querySelectorAll(\u0026#39;.box\u0026#39;).forEach(element =\u0026gt; { element.addEventListener(\u0026#34;click\u0026#34;, function(event) { console.log(this.classList.value) event.stopPropagation() }, { // capture:true  } ) })  Cơ chế bubble với stopPropagation   Cơ chế capture với stopPropagation \nWednesday 31/03/2021\n","date":"2021-03-31T11:14:24+07:00","image":"https://sonlhcsuit.github.io/p/event-bubbles/cover_hud38f19311a47fb7e81e0a14471226114_599984_120x120_fill_box_smart1_2.png","permalink":"https://sonlhcsuit.github.io/p/event-bubbles/","title":"Event Bubbling \u0026 Capturing"},{"content":"Hôm nay cũng như bao hôm khác, sẽ là một ngày chủ nhật thật đẹp với bầu trời xanh của thành phố quen thuộc.\nMới vừa bước ra công ty sau một ngày chủ nhật mệt mỏi, lái trên đường về dọc kênh Nhiêu Lộc - Thị Nghè. Đang trên đường mà cứ thả hồn vào trời mây, việc lái xe thì nhường lại cho tay chân với phản xạ cơ bản.\nKhông hiểu vì lí do gì mà cảm xúc trống rỗng, buồn,\u0026hellip; lấp đầy tâm trí. Không biết buồn vì điều chi, chỉ cảm thấy thiếu 1 thứ gì đó rất quan trọng.\nCàng lớn, cảm xúc tích cực càng ít đi, thay vào đó là những khoảng lặng.\nSực nhớ ra hôm nay là valentine trắng, dường như chính cảm xúc mình lại chết một ít.\nSunday 14/03/21\n","date":"2021-03-15T01:17:31+07:00","image":"https://sonlhcsuit.github.io/p/valentine-trang/cover_hu7a3348dd1f670f38516753d703135e0a_1056819_120x120_fill_box_smart1_2.png","permalink":"https://sonlhcsuit.github.io/p/valentine-trang/","title":"Valentine Trang"}]